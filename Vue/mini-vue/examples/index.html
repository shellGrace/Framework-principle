<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Vue ç¤ºä¾‹</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .counter {
            text-align: center;
            margin: 20px 0;
        }
        .counter h1 {
            color: #42b883;
            margin-bottom: 20px;
        }
        .counter p {
            font-size: 18px;
            margin: 10px 0;
            color: #333;
        }
        .counter button {
            background: #42b883;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .counter button:hover {
            background: #369870;
        }
        .todo-app {
            margin-top: 30px;
        }
        .todo-input {
            width: 70%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .todo-add {
            width: 25%;
            padding: 10px;
            background: #42b883;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-left: 5px;
        }
        .todo-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }
        .todo-item {
            background: #f9f9f9;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .todo-item.completed {
            text-decoration: line-through;
            opacity: 0.6;
        }
        .todo-delete {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ Mini Vue æ¡†æ¶æ¼”ç¤º</h1>
        <p>è¿™æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆçš„ Vue.js å®ç°ï¼ŒåŒ…å«å“åº”å¼ç³»ç»Ÿã€è™šæ‹ŸDOMã€ç»„ä»¶ç³»ç»Ÿç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚</p>
        
        <!-- è®¡æ•°å™¨åº”ç”¨æŒ‚è½½ç‚¹ -->
        <div id="counter-app"></div>
        
        <!-- Todoåº”ç”¨æŒ‚è½½ç‚¹ -->
        <div id="todo-app"></div>
    </div>

    <script>
        // Mini Vue æ ¸å¿ƒå®ç°ï¼ˆç®€åŒ–ç‰ˆï¼Œé€‚ç”¨äºæµè§ˆå™¨ï¼‰
        
        // å“åº”å¼ç³»ç»Ÿ
        let activeEffect = null;
        const targetMap = new WeakMap();
        
        function track(target, key) {
            if (!activeEffect) return;
            let depsMap = targetMap.get(target);
            if (!depsMap) {
                targetMap.set(target, (depsMap = new Map()));
            }
            let dep = depsMap.get(key);
            if (!dep) {
                depsMap.set(key, (dep = new Set()));
            }
            dep.add(activeEffect);
        }
        
        function trigger(target, key) {
            const depsMap = targetMap.get(target);
            if (!depsMap) return;
            const dep = depsMap.get(key);
            if (dep) {
                dep.forEach(effect => effect());
            }
        }
        
        function reactive(target) {
            if (typeof target !== 'object' || target === null) {
                return target;
            }
            return new Proxy(target, {
                get(target, key, receiver) {
                    const result = Reflect.get(target, key, receiver);
                    track(target, key);
                    return result;
                },
                set(target, key, value, receiver) {
                    const result = Reflect.set(target, key, value, receiver);
                    trigger(target, key);
                    return result;
                }
            });
        }
        
        function ref(value) {
            return {
                _isRef: true,
                get value() {
                    track(this, 'value');
                    return value;
                },
                set value(newValue) {
                    value = newValue;
                    trigger(this, 'value');
                }
            };
        }
        
        function effect(fn) {
            const effectFn = () => {
                activeEffect = effectFn;
                fn();
                activeEffect = null;
            };
            effectFn();
            return effectFn;
        }
        
        function computed(getter) {
            let value;
            let dirty = true;
            const computedRef = {
                get value() {
                    if (dirty) {
                        value = getter();
                        dirty = false;
                    }
                    track(computedRef, 'value');
                    return value;
                }
            };
            effect(() => {
                getter();
                dirty = true;
                trigger(computedRef, 'value');
            });
            return computedRef;
        }
        
        // è™šæ‹ŸDOM
        function h(tag, props = {}, children = []) {
            return {
                tag,
                props,
                children,
                el: null
            };
        }
        
        function mount(vnode, container) {
            const el = document.createElement(vnode.tag);
            vnode.el = el;
            
            if (vnode.props) {
                for (const key in vnode.props) {
                    const value = vnode.props[key];
                    if (key.startsWith('on')) {
                        const event = key.slice(2).toLowerCase();
                        el.addEventListener(event, value);
                    } else {
                        el.setAttribute(key, value);
                    }
                }
            }
            
            if (vnode.children) {
                if (Array.isArray(vnode.children)) {
                    vnode.children.forEach(child => {
                        if (typeof child === 'string') {
                            el.appendChild(document.createTextNode(child));
                        } else {
                            mount(child, el);
                        }
                    });
                } else if (typeof vnode.children === 'string') {
                    el.appendChild(document.createTextNode(vnode.children));
                }
            }
            
            container.appendChild(el);
        }
        
        function patch(oldVNode, newVNode) {
            if (oldVNode.tag !== newVNode.tag) {
                const newEl = document.createElement(newVNode.tag);
                newVNode.el = newEl;
                oldVNode.el.parentNode.replaceChild(newEl, oldVNode.el);
                mount(newVNode, newEl.parentNode);
                return;
            }
            
            const el = newVNode.el = oldVNode.el;
            
            // æ›´æ–°å±æ€§
            const oldProps = oldVNode.props || {};
            const newProps = newVNode.props || {};
            
            for (const key in newProps) {
                const oldValue = oldProps[key];
                const newValue = newProps[key];
                if (newValue !== oldValue) {
                    if (key.startsWith('on')) {
                        const event = key.slice(2).toLowerCase();
                        if (oldValue) {
                            el.removeEventListener(event, oldValue);
                        }
                        el.addEventListener(event, newValue);
                    } else {
                        el.setAttribute(key, newValue);
                    }
                }
            }
            
            for (const key in oldProps) {
                if (!(key in newProps)) {
                    if (key.startsWith('on')) {
                        const event = key.slice(2).toLowerCase();
                        el.removeEventListener(event, oldProps[key]);
                    } else {
                        el.removeAttribute(key);
                    }
                }
            }
            
            // æ›´æ–°å­èŠ‚ç‚¹
            const oldChildren = Array.isArray(oldVNode.children) ? oldVNode.children : (oldVNode.children ? [oldVNode.children] : []);
            const newChildren = Array.isArray(newVNode.children) ? newVNode.children : (newVNode.children ? [newVNode.children] : []);
            const commonLength = Math.min(oldChildren.length, newChildren.length);
            
            for (let i = 0; i < commonLength; i++) {
                const oldChild = oldChildren[i];
                const newChild = newChildren[i];
                if (typeof oldChild === 'string' && typeof newChild === 'string') {
                    if (oldChild !== newChild) {
                        el.childNodes[i].textContent = newChild;
                    }
                } else if (typeof oldChild === 'object' && typeof newChild === 'object') {
                    patch(oldChild, newChild);
                }
            }
            
            if (newChildren.length > oldChildren.length) {
                for (let i = commonLength; i < newChildren.length; i++) {
                    const child = newChildren[i];
                    if (typeof child === 'string') {
                        el.appendChild(document.createTextNode(child));
                    } else {
                        mount(child, el);
                    }
                }
            }
            
            if (oldChildren.length > newChildren.length) {
                for (let i = commonLength; i < oldChildren.length; i++) {
                    el.removeChild(el.childNodes[commonLength]);
                }
            }
        }
        
        // ç®€åŒ–çš„åº”ç”¨åˆ›å»º
        function createApp(component) {
            return {
                mount(selector) {
                    const container = document.querySelector(selector);
                    let isMounted = false;
                    let prevVNode = null;
                    
                    const update = effect(() => {
                        const vnode = component.render();
                        if (!isMounted) {
                            mount(vnode, container);
                            isMounted = true;
                        } else {
                            patch(prevVNode, vnode);
                        }
                        prevVNode = vnode;
                    });
                }
            };
        }
        
        // è®¡æ•°å™¨ç»„ä»¶
        const CounterApp = {
            render() {
                return h('div', { class: 'counter' }, [
                    h('h1', {}, this.message.value),
                    h('p', {}, `è®¡æ•°: ${this.count.value}`),
                    h('p', {}, `åŒå€è®¡æ•°: ${this.doubleCount.value}`),
                    h('button', { onClick: this.increment }, 'å¢åŠ '),
                    h('button', { onClick: this.decrement }, 'å‡å°‘'),
                    h('button', { onClick: this.reset }, 'é‡ç½®')
                ]);
            }
        };
        
        // åˆå§‹åŒ–è®¡æ•°å™¨
        const count = ref(0);
        const message = ref('ğŸ¯ Mini Vue è®¡æ•°å™¨');
        const doubleCount = computed(() => count.value * 2);
        
        CounterApp.count = count;
        CounterApp.message = message;
        CounterApp.doubleCount = doubleCount;
        CounterApp.increment = () => count.value++;
        CounterApp.decrement = () => count.value--;
        CounterApp.reset = () => count.value = 0;
        
        // Todoåº”ç”¨
        const TodoApp = {
            render() {
                return h('div', { class: 'todo-app' }, [
                    h('h2', {}, 'ğŸ“ Todo åº”ç”¨'),
                    h('div', {}, [
                        h('input', {
                            class: 'todo-input',
                            value: this.newTodo.value,
                            onInput: (e) => this.newTodo.value = e.target.value,
                            placeholder: 'è¾“å…¥æ–°çš„å¾…åŠäº‹é¡¹...'
                        }),
                        h('button', {
                            class: 'todo-add',
                            onClick: this.addTodo
                        }, 'æ·»åŠ ')
                    ]),
                    h('ul', { class: 'todo-list' }, 
                        this.todos.value.map((todo, index) => 
                            h('li', {
                                class: todo.completed ? 'todo-item completed' : 'todo-item'
                            }, [
                                h('span', {
                                    onClick: () => this.toggleTodo(index)
                                }, todo.text),
                                h('button', {
                                    class: 'todo-delete',
                                    onClick: () => this.deleteTodo(index)
                                }, 'åˆ é™¤')
                            ])
                        )
                    )
                ]);
            }
        };
        
        // åˆå§‹åŒ–Todoåº”ç”¨
        const newTodo = ref('');
        const todos = ref([
            { text: 'å­¦ä¹  Vue åŸç†', completed: false },
            { text: 'å®ç° Mini Vue', completed: true }
        ]);
        
        TodoApp.newTodo = newTodo;
        TodoApp.todos = todos;
        TodoApp.addTodo = () => {
            if (newTodo.value.trim()) {
                todos.value.push({
                    text: newTodo.value,
                    completed: false
                });
                newTodo.value = '';
            }
        };
        TodoApp.toggleTodo = (index) => {
            todos.value[index].completed = !todos.value[index].completed;
        };
        TodoApp.deleteTodo = (index) => {
            todos.value.splice(index, 1);
        };
        
        // æŒ‚è½½åº”ç”¨
        createApp(CounterApp).mount('#counter-app');
        createApp(TodoApp).mount('#todo-app');
        
        console.log('Mini Vue åº”ç”¨å·²å¯åŠ¨!');
    </script>
</body>
</html>