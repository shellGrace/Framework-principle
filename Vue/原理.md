# Vue 核心原理知识点总结（重点）

## 1. 响应式系统 (Reactivity System) ⭐⭐⭐⭐⭐

### Vue 2.x 响应式原理（高频）
- **Object.defineProperty()**: 通过劫持对象属性的 getter/setter 实现响应式
- **依赖收集**: Dep 类收集依赖，Watcher 类作为观察者
- **派发更新**: 数据变化时通知所有依赖进行更新
- **数组响应式**: 重写数组的变异方法（push、pop、shift、unshift、splice、sort、reverse）
- **深度监听**: 递归遍历对象属性，为每个属性添加响应式

### Vue 2.x 响应式实现
```javascript
function defineReactive(obj, key, val) {
  const dep = new Dep();
  
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get() {
      // 依赖收集
      if (Dep.target) {
        dep.depend();
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return;
      val = newVal;
      // 派发更新
      dep.notify();
    }
  });
}
```

### Vue 3.x 响应式原理
- **Proxy**: 使用 Proxy 代理整个对象，解决 Vue 2.x 的局限性
- **Reflect**: 配合 Proxy 使用，提供更好的错误处理
- **ref 和 reactive**: 两种创建响应式数据的方式
- **effect**: 副作用函数，替代 Vue 2.x 的 Watcher
- **track 和 trigger**: 依赖收集和触发更新的核心函数

### Vue 3.x 响应式实现
```javascript
const reactive = (target) => {
  return new Proxy(target, {
    get(target, key, receiver) {
      const result = Reflect.get(target, key, receiver);
      // 依赖收集
      track(target, key);
      return result;
    },
    set(target, key, value, receiver) {
      const result = Reflect.set(target, key, value, receiver);
      // 触发更新
      trigger(target, key);
      return result;
    }
  });
};
```

### Vue 2 vs Vue 3 响应式对比（必问）
| 特性 | Vue 2 | Vue 3 |
|------|-------|-------|
| 实现方式 | Object.defineProperty | Proxy |
| 数组监听 | 重写数组方法 | 原生支持 |
| 对象新增属性 | 需要 Vue.set | 原生支持 |
| 性能 | 递归遍历所有属性 | 懒代理，按需响应式 |
| 兼容性 | IE8+ | IE11+ |

## 2. 虚拟 DOM (Virtual DOM) ⭐⭐⭐⭐⭐

### 核心概念
- **VNode**: 虚拟节点，用 JavaScript 对象描述真实 DOM
- **diff 算法**: 比较新旧虚拟 DOM 树的差异
- **patch**: 将 diff 结果应用到真实 DOM 上

### VNode 结构
```javascript
{
  tag: 'div',           // 标签名
  data: {               // 数据对象
    class: 'container',
    style: { color: 'red' }
  },
  children: [],         // 子节点
  text: undefined,      // 文本内容
  elm: undefined,       // 对应的真实 DOM 节点
  key: undefined        // 节点的 key
}
```

### diff 算法优化（重点）
#### Vue 2.x - 双端比较
- **同层比较**: 只比较同一层级的节点
- **双端比较**: 新旧节点列表的头尾四个节点进行比较
- **key 的作用**: 帮助 diff 算法识别节点，提高复用率

#### Vue 3.x - 最长递增子序列
- **静态标记**: 编译时标记静态节点
- **最长递增子序列**: 最小化 DOM 移动操作
- **Block Tree**: 收集动态节点，跳过静态节点

### diff 算法实现（简化版）
```javascript
function updateChildren(oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let newEndIdx = newCh.length - 1;
  
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (sameVnode(oldStartVnode, newStartVnode)) {
      // 头头比较
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      // 尾尾比较
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    }
    // ... 其他比较逻辑
  }
}
```

## 3. 组件系统 (Component System) ⭐⭐⭐⭐

### 组件生命周期（高频）
#### Vue 2.x 生命周期
- **创建阶段**: beforeCreate、created
- **挂载阶段**: beforeMount、mounted
- **更新阶段**: beforeUpdate、updated
- **销毁阶段**: beforeDestroy、destroyed

#### Vue 3.x 生命周期
- **setup()**: Composition API 的入口
- **onMounted、onUpdated、onUnmounted** 等组合式 API

### 生命周期执行顺序
```
父beforeCreate -> 父created -> 父beforeMount -> 
子beforeCreate -> 子created -> 子beforeMount -> 
子mounted -> 父mounted
```

### 组件通信方式（必考）
1. **props / emit**: 父子组件通信
2. **provide / inject**: 跨层级组件通信
3. **$parent / $children**: 直接访问父子组件实例
4. **$refs**: 获取子组件引用
5. **EventBus**: 事件总线（Vue 3 移除）
6. **Vuex / Pinia**: 全局状态管理
7. **$attrs / $listeners**: 透传属性和事件

### 组件通信代码示例
```javascript
// 1. props/emit
// 父组件
<child-component :msg="message" @update="handleUpdate" />

// 子组件
props: ['msg'],
methods: {
  updateParent() {
    this.$emit('update', newValue);
  }
}

// 2. provide/inject
// 祖先组件
provide() {
  return {
    theme: this.theme
  };
}

// 后代组件
inject: ['theme']
```

## 4. 编译原理 (Compilation) ⭐⭐⭐⭐

### 模板编译过程
1. **解析 (Parse)**: 将模板字符串解析成 AST（抽象语法树）
2. **转换 (Transform)**: 对 AST 进行优化和转换
3. **生成 (Generate)**: 将 AST 转换成渲染函数代码

### 编译过程详解
```javascript
// 模板
<div id="app">
  <p>{{ message }}</p>
</div>

// 解析后的 AST
{
  type: 1,
  tag: 'div',
  attrsList: [{ name: 'id', value: 'app' }],
  children: [
    {
      type: 1,
      tag: 'p',
      children: [
        {
          type: 2,
          expression: '_s(message)',
          text: '{{ message }}'
        }
      ]
    }
  ]
}

// 生成的渲染函数
function render() {
  with(this) {
    return _c('div', { attrs: { id: 'app' } }, [
      _c('p', [_v(_s(message))])
    ]);
  }
}
```

### 指令系统（重点）
#### v-if vs v-show
- **v-if**: 条件性渲染，切换时会销毁/重建元素
- **v-show**: 切换 CSS display 属性，元素始终存在
- **性能对比**: v-if 切换开销大，v-show 初始渲染开销大

#### v-for 实现原理
```javascript
// 模板
<li v-for="item in list" :key="item.id">{{ item.name }}</li>

// 编译后
function renderList(val, render) {
  let ret = [];
  for (let i = 0; i < val.length; i++) {
    ret.push(render(val[i], i));
  }
  return ret;
}
```

#### v-model 实现原理
```javascript
// 模板
<input v-model="message" />

// 编译后
<input 
  :value="message" 
  @input="message = $event.target.value"
/>
```

## 5. 渲染机制 (Rendering) ⭐⭐⭐⭐

### 渲染函数
- **render 函数**: 组件的渲染函数
- **h 函数**: 创建 VNode 的辅助函数
- **JSX**: 在 Vue 中使用 JSX 语法

### 异步更新队列（重点）
- **nextTick**: 在下次 DOM 更新循环结束后执行回调
- **批量更新**: 将多次数据变更合并为一次 DOM 更新
- **微任务队列**: 利用 Promise.then 实现异步更新

### nextTick 实现原理
```javascript
let callbacks = [];
let pending = false;

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice(0);
  callbacks.length = 0;
  for (let i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

function nextTick(cb) {
  callbacks.push(cb);
  if (!pending) {
    pending = true;
    Promise.resolve().then(flushCallbacks);
  }
}
```

## 6. Composition API (Vue 3.x) ⭐⭐⭐⭐⭐

### 核心 API
- **setup()**: 组合式 API 的入口函数
- **ref()**: 创建响应式引用
- **reactive()**: 创建响应式对象
- **computed()**: 计算属性
- **watch/watchEffect()**: 侦听器

### ref vs reactive（常问）
| 特性 | ref | reactive |
|------|-----|----------|
| 数据类型 | 基本类型 + 对象 | 对象类型 |
| 访问方式 | .value | 直接访问 |
| 模板中 | 自动解包 | 直接使用 |
| 响应式 | 整个 ref 对象 | 对象的属性 |

### Composition API 示例
```javascript
import { ref, reactive, computed, watch } from 'vue';

export default {
  setup() {
    // 响应式数据
    const count = ref(0);
    const state = reactive({ name: 'Vue' });
    
    // 计算属性
    const doubleCount = computed(() => count.value * 2);
    
    // 侦听器
    watch(count, (newVal, oldVal) => {
      console.log(`count changed: ${oldVal} -> ${newVal}`);
    });
    
    // 方法
    const increment = () => {
      count.value++;
    };
    
    return {
      count,
      state,
      doubleCount,
      increment
    };
  }
};
```

### 逻辑复用
- **组合函数**: 提取和复用组件逻辑
- **自定义 Hook**: 封装可复用的状态逻辑

```javascript
// 自定义组合函数
function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  const increment = () => count.value++;
  const decrement = () => count.value--;
  
  return {
    count,
    increment,
    decrement
  };
}
```

## 7. 路由原理 (Vue Router) ⭐⭐⭐⭐

### 路由模式
- **Hash 模式**: 使用 URL hash 实现前端路由
- **History 模式**: 使用 HTML5 History API
- **Memory 模式**: 在内存中管理路由历史

### 路由模式实现
```javascript
// Hash 模式
class HashRouter {
  constructor() {
    this.routes = {};
    this.currentUrl = '';
    this.refresh = this.refresh.bind(this);
    window.addEventListener('load', this.refresh);
    window.addEventListener('hashchange', this.refresh);
  }
  
  refresh() {
    this.currentUrl = location.hash.slice(1) || '/';
    this.routes[this.currentUrl] && this.routes[this.currentUrl]();
  }
}

// History 模式
class HistoryRouter {
  constructor() {
    this.routes = {};
    this.init();
  }
  
  init() {
    window.addEventListener('popstate', (e) => {
      const path = e.state && e.state.path;
      this.routes[path] && this.routes[path]();
    });
  }
  
  push(path) {
    history.pushState({ path }, null, path);
    this.routes[path] && this.routes[path]();
  }
}
```

### 核心概念
- **路由匹配**: 根据 URL 匹配对应的组件
- **导航守卫**: 路由跳转的钩子函数
- **动态路由**: 带参数的路由匹配

### 导航守卫执行顺序
```
1. 导航被触发
2. 在失活的组件里调用 beforeRouteLeave 守卫
3. 调用全局的 beforeEach 守卫
4. 在重用的组件里调用 beforeRouteUpdate 守卫
5. 在路由配置里调用 beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用 beforeRouteEnter
8. 调用全局的 beforeResolve 守卫
9. 导航被确认
10. 调用全局的 afterEach 钩子
11. 触发 DOM 更新
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数
```

## 8. 状态管理 (Vuex/Pinia) ⭐⭐⭐⭐

### Vuex 核心概念
- **State**: 单一状态树
- **Getters**: 状态的计算属性
- **Mutations**: 同步修改状态的方法
- **Actions**: 异步操作和业务逻辑
- **Modules**: 模块化状态管理

### Vuex 工作流程
```
Vue Component -> dispatch -> Actions -> commit -> Mutations -> State -> Vue Component
```

### Vuex 实现原理
```javascript
class Store {
  constructor(options) {
    this.state = new Vue({
      data: options.state
    });
    
    this.mutations = options.mutations || {};
    this.actions = options.actions || {};
    
    this.commit = this.commit.bind(this);
    this.dispatch = this.dispatch.bind(this);
  }
  
  commit(type, payload) {
    const mutation = this.mutations[type];
    if (mutation) {
      mutation(this.state, payload);
    }
  }
  
  dispatch(type, payload) {
    const action = this.actions[type];
    if (action) {
      return action({
        commit: this.commit,
        state: this.state
      }, payload);
    }
  }
}
```

### Pinia (Vue 3.x 推荐)
- **Store**: 状态存储
- **State**: 状态定义
- **Getters**: 计算属性
- **Actions**: 同步和异步操作

```javascript
// Pinia Store
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  getters: {
    doubleCount: (state) => state.count * 2
  },
  actions: {
    increment() {
      this.count++;
    }
  }
});
```

## 9. 性能优化 ⭐⭐⭐⭐⭐

### 编译时优化（Vue 3.x）
- **静态提升**: 将静态节点提升到渲染函数外部
- **预字符串化**: 将连续的静态节点序列化为字符串
- **内联组件 props**: 优化组件 props 的传递
- **Tree-shaking**: 移除未使用的代码

### 运行时优化
- **组件缓存**: keep-alive 组件缓存
- **异步组件**: 代码分割和懒加载
- **虚拟滚动**: 处理大量数据的列表渲染
- **函数式组件**: 无状态组件优化

### 性能优化策略
```javascript
// 1. 使用 v-show 替代 v-if（频繁切换）
<div v-show="isVisible">Content</div>

// 2. 使用 key 优化列表渲染
<li v-for="item in list" :key="item.id">{{ item.name }}</li>

// 3. 使用计算属性缓存复杂计算
computed: {
  expensiveValue() {
    return this.list.filter(item => item.active).length;
  }
}

// 4. 使用 Object.freeze 冻结数据
data() {
  return {
    list: Object.freeze(largeList)
  };
}
```

## 10. 源码架构 ⭐⭐⭐

### Vue 2.x 目录结构
- **core**: 核心代码（响应式、组件、虚拟 DOM）
- **compiler**: 编译器相关代码
- **platforms**: 平台特定代码
- **server**: 服务端渲染
- **shared**: 共享工具函数

### Vue 3.x 目录结构
- **reactivity**: 响应式系统
- **runtime-core**: 运行时核心
- **runtime-dom**: DOM 相关运行时
- **compiler-core**: 编译器核心
- **compiler-dom**: DOM 编译器

### 设计模式
- **观察者模式**: 响应式系统的核心
- **发布订阅模式**: 事件系统的实现
- **策略模式**: 不同平台的渲染策略
- **工厂模式**: 组件实例的创建

## 11. Vue 3.x 新特性 ⭐⭐⭐⭐

### 性能提升
- **更小的包体积**: Tree-shaking 支持
- **更快的渲染**: 编译时优化
- **更好的内存使用**: Proxy 响应式

### 新增特性
- **Composition API**: 更好的逻辑复用
- **Teleport**: 传送门组件
- **Fragments**: 多根节点组件
- **Suspense**: 异步组件处理

### 破坏性变更
- **全局 API 变更**: createApp 替代 new Vue
- **事件 API 移除**: $on、$off、$once
- **过滤器移除**: filters 不再支持
- **内联模板移除**: inline-template 不再支持

## 12. 常考算法题

### 手写响应式系统
```javascript
// 简化版 Vue 2 响应式
class Observer {
  constructor(data) {
    this.walk(data);
  }
  
  walk(data) {
    Object.keys(data).forEach(key => {
      this.defineReactive(data, key, data[key]);
    });
  }
  
  defineReactive(obj, key, val) {
    const dep = new Dep();
    
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get() {
        if (Dep.target) {
          dep.depend();
        }
        return val;
      },
      set(newVal) {
        if (newVal === val) return;
        val = newVal;
        dep.notify();
      }
    });
  }
}

class Dep {
  constructor() {
    this.subs = [];
  }
  
  depend() {
    if (Dep.target) {
      this.subs.push(Dep.target);
    }
  }
  
  notify() {
    this.subs.forEach(sub => sub.update());
  }
}

class Watcher {
  constructor(vm, exp, cb) {
    this.vm = vm;
    this.exp = exp;
    this.cb = cb;
    this.value = this.get();
  }
  
  get() {
    Dep.target = this;
    const value = this.vm[this.exp];
    Dep.target = null;
    return value;
  }
  
  update() {
    const newValue = this.get();
    if (newValue !== this.value) {
      this.value = newValue;
      this.cb.call(this.vm, newValue);
    }
  }
}
```

### 手写简单的 diff 算法
```javascript
function diff(oldVnode, newVnode) {
  // 节点类型不同，直接替换
  if (oldVnode.tag !== newVnode.tag) {
    return { type: 'REPLACE', newVnode };
  }
  
  // 文本节点
  if (typeof newVnode === 'string') {
    if (oldVnode !== newVnode) {
      return { type: 'TEXT', text: newVnode };
    }
    return null;
  }
  
  // 比较属性
  const propsPatches = diffProps(oldVnode.props, newVnode.props);
  
  // 比较子节点
  const childrenPatches = diffChildren(oldVnode.children, newVnode.children);
  
  return {
    type: 'UPDATE',
    props: propsPatches,
    children: childrenPatches
  };
}
```

## 13. 重点总结

### 必须掌握的概念
1. **响应式原理**: Object.defineProperty vs Proxy
2. **虚拟 DOM 和 diff 算法**
3. **组件生命周期和通信方式**
4. **模板编译过程**
5. **Composition API 使用和原理**
6. **路由原理和导航守卫**
7. **状态管理模式**
8. **性能优化策略**

### 常见题
1. Vue 2 和 Vue 3 的区别？
2. Vue 的响应式原理是什么？
3. v-if 和 v-show 的区别？
4. Vue 组件间通信有哪些方式？
5. Vue 的生命周期有哪些？
6. nextTick 的实现原理？
7. keep-alive 的实现原理？
8. Vuex 和 Pinia 的区别？
9. Vue 3 的 Composition API 有什么优势？
10. Vue 的性能优化手段有哪些？

### Vue vs React 对比（常问）
| 特性 | Vue | React |
|------|-----|-------|
| 学习曲线 | 平缓 | 陡峭 |
| 模板语法 | 模板 | JSX |
| 状态管理 | Vuex/Pinia | Redux/Context |
| 响应式 | 自动依赖收集 | 手动优化 |
| 组件通信 | 多种方式 | props/callback |
| 生态系统 | 官方维护 | 社区驱动 |

### 学习建议
1. **理论结合实践**: 理解原理的同时多写代码
2. **源码阅读**: 阅读 Vue 源码加深理解
3. **性能调优**: 学会使用 Vue DevTools 分析性能
4. **跟进新特性**: 关注 Vue 的最新发展和 RFC 提案
5. **项目实战**: 在实际项目中应用所学知识

## 参考资源

- [Vue.js 官方文档](https://vuejs.org/)
- [Vue.js 源码](https://github.com/vuejs/vue)
- [Vue 3 源码](https://github.com/vuejs/core)
- [Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)
- [Vue 3 深入响应式原理](https://vue-next-template-explorer.netlify.app/)