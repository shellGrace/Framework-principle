# Webpack 核心原理 - 重点总结

## 1. Webpack 基本概念 ⭐⭐⭐⭐⭐

### 1.1 核心概念

**Entry（入口）**
```javascript
module.exports = {
  entry: {
    main: './src/index.js',
    vendor: './src/vendor.js'
  }
};
```

**Output（输出）**
```javascript
module.exports = {
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    publicPath: '/assets/'
  }
};
```

**Loader（加载器）**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
};
```

**Plugin（插件）**
```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');

module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html'
    })
  ]
};
```

### 1.2 常考问题

**Q: Loader和Plugin的区别？**
- **Loader**: 文件转换器，处理特定类型文件（如CSS、图片）
- **Plugin**: 功能扩展器，在构建过程的特定时机执行特定任务

## 2. Webpack 构建流程 ⭐⭐⭐⭐⭐

### 2.1 完整构建流程

```
初始化参数 ──▶ 开始编译 ──▶ 确定入口 ──▶ 编译模块 ──▶ 完成模块编译
     │                                              │
     ▼                                              ▼
配置文件+命令行                                  输出资源
     │                                              │
     ▼                                              ▼
创建Compiler ──▶ 创建Compilation ──▶ 构建依赖图 ──▶ 生成Bundle
```

### 2.2 核心阶段详解

**1. 初始化阶段**
```javascript
// 1. 读取配置文件
const config = require('./webpack.config.js');

// 2. 创建Compiler实例
const compiler = webpack(config);

// 3. 注册插件
config.plugins.forEach(plugin => {
  plugin.apply(compiler);
});
```

**2. 编译阶段**
```javascript
// 简化的编译流程
class Compiler {
  run(callback) {
    // 创建Compilation
    const compilation = this.newCompilation();
    
    // 从入口开始构建
    compilation.addEntry(this.options.entry);
    
    // 构建模块
    compilation.buildModule();
    
    // 生成资源
    compilation.seal();
    
    // 输出文件
    this.emitAssets(compilation);
  }
}
```

**3. 输出阶段**
```javascript
// 生成最终的bundle文件
class Compilation {
  seal() {
    // 优化模块
    this.optimize();
    
    // 生成chunk
    this.createChunks();
    
    // 生成代码
    this.createChunkAssets();
  }
}
```

### 2.3 重点

**Q: 描述Webpack的构建流程？**
1. **初始化**: 读取配置，创建Compiler
2. **编译**: 从entry开始，递归解析依赖
3. **构建**: 使用Loader转换文件，生成AST
4. **优化**: Tree Shaking、代码分割等
5. **输出**: 生成最终的bundle文件

## 3. 模块解析机制 ⭐⭐⭐⭐

### 3.1 模块类型

**ES6 模块**
```javascript
// export
export const name = 'webpack';
export default function() {}

// import
import { name } from './module';
import defaultExport from './module';
```

**CommonJS 模块**
```javascript
// exports
module.exports = { name: 'webpack' };
exports.name = 'webpack';

// require
const { name } = require('./module');
```

**AMD 模块**
```javascript
// define
define(['dependency'], function(dep) {
  return { name: 'webpack' };
});

// require
require(['module'], function(module) {
  // use module
});
```

### 3.2 依赖图构建

```javascript
// 简化的依赖解析
class ModuleResolver {
  resolve(request, context) {
    // 1. 解析模块路径
    const modulePath = this.resolvePath(request, context);
    
    // 2. 读取文件内容
    const source = fs.readFileSync(modulePath, 'utf8');
    
    // 3. 解析依赖
    const dependencies = this.parseDependencies(source);
    
    // 4. 递归处理依赖
    dependencies.forEach(dep => {
      this.resolve(dep, modulePath);
    });
    
    return {
      path: modulePath,
      source,
      dependencies
    };
  }
  
  parseDependencies(source) {
    const ast = parser.parse(source);
    const dependencies = [];
    
    traverse(ast, {
      ImportDeclaration(path) {
        dependencies.push(path.node.source.value);
      },
      CallExpression(path) {
        if (path.node.callee.name === 'require') {
          dependencies.push(path.node.arguments[0].value);
        }
      }
    });
    
    return dependencies;
  }
}
```

### 3.3 考点

**Q: Webpack如何解析模块？**
1. **路径解析**: 根据resolve配置解析模块路径
2. **文件读取**: 读取模块文件内容
3. **依赖分析**: 使用AST分析模块依赖
4. **递归处理**: 递归处理所有依赖模块

## 4. Loader 原理 ⭐⭐⭐⭐

### 4.1 Loader 本质

```javascript
// Loader就是一个函数
module.exports = function(source) {
  // source是文件内容
  // 返回转换后的内容
  return transformedSource;
};

// 异步Loader
module.exports = function(source) {
  const callback = this.async();
  
  // 异步处理
  setTimeout(() => {
    callback(null, transformedSource);
  }, 1000);
};
```

### 4.2 常见Loader实现

**babel-loader 简化实现**
```javascript
const babel = require('@babel/core');

module.exports = function(source) {
  const options = this.getOptions();
  
  const result = babel.transformSync(source, {
    presets: options.presets,
    plugins: options.plugins
  });
  
  return result.code;
};
```

**css-loader 简化实现**
```javascript
module.exports = function(source) {
  // 处理CSS中的@import和url()
  const processedCSS = source
    .replace(/@import\s+['"]([^'"]+)['"]/g, (match, url) => {
      // 处理@import
      return `require('${url}')`;
    })
    .replace(/url\(([^)]+)\)/g, (match, url) => {
      // 处理url()
      return `url(${JSON.stringify(url)})`;
    });
  
  return `module.exports = ${JSON.stringify(processedCSS)}`;
};
```

**file-loader 简化实现**
```javascript
const path = require('path');

module.exports = function(content) {
  const options = this.getOptions();
  const filename = path.basename(this.resourcePath);
  
  // 生成文件名
  const outputPath = options.name || '[name].[ext]';
  const finalPath = outputPath.replace('[name]', path.parse(filename).name)
                              .replace('[ext]', path.parse(filename).ext);
  
  // 输出文件
  this.emitFile(finalPath, content);
  
  // 返回文件路径
  return `module.exports = ${JSON.stringify(finalPath)}`;
};

// 标记为raw loader，处理二进制文件
module.exports.raw = true;
```

### 4.3 Loader 执行顺序

```javascript
// 配置
{
  test: /\.css$/,
  use: ['style-loader', 'css-loader', 'postcss-loader']
}

// 执行顺序：从右到左，从下到上
// postcss-loader -> css-loader -> style-loader
```

### 4.4 重点

**Q: 如何编写一个Loader？**
```javascript
// 1. 基本结构
module.exports = function(source) {
  // 获取配置选项
  const options = this.getOptions();
  
  // 处理source
  const result = transform(source, options);
  
  // 返回结果
  return result;
};

// 2. 异步处理
module.exports = function(source) {
  const callback = this.async();
  
  processAsync(source).then(result => {
    callback(null, result);
  }).catch(err => {
    callback(err);
  });
};

// 3. 返回多个结果
module.exports = function(source) {
  const callback = this.async();
  
  const result = transform(source);
  const sourceMap = generateSourceMap(source, result);
  
  callback(null, result, sourceMap);
};
```

## 5. Plugin 原理 ⭐⭐⭐⭐⭐

### 5.1 Plugin 基本结构

```javascript
class MyPlugin {
  constructor(options) {
    this.options = options;
  }
  
  apply(compiler) {
    // 监听钩子
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      // 在生成文件前执行
      console.log('生成文件前执行');
      
      // 修改资源
      compilation.assets['hello.txt'] = {
        source: () => 'Hello World',
        size: () => 11
      };
      
      callback();
    });
  }
}

module.exports = MyPlugin;
```

### 5.2 常用钩子

```javascript
class CompilerHooksPlugin {
  apply(compiler) {
    // 编译开始
    compiler.hooks.run.tap('MyPlugin', () => {
      console.log('开始编译');
    });
    
    // 编译完成
    compiler.hooks.done.tap('MyPlugin', (stats) => {
      console.log('编译完成');
    });
    
    // 生成资源前
    compiler.hooks.emit.tapAsync('MyPlugin', (compilation, callback) => {
      console.log('生成资源前');
      callback();
    });
  }
}

class CompilationHooksPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('MyPlugin', (compilation) => {
      // 优化阶段
      compilation.hooks.optimize.tap('MyPlugin', () => {
        console.log('优化阶段');
      });
      
      // 生成chunk资源
      compilation.hooks.chunkAsset.tap('MyPlugin', (chunk, filename) => {
        console.log(`生成chunk资源: ${filename}`);
      });
    });
  }
}
```

### 5.3 实际Plugin示例

**文件列表插件**
```javascript
class FileListPlugin {
  constructor(options) {
    this.filename = options.filename || 'filelist.md';
  }
  
  apply(compiler) {
    compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) => {
      // 获取所有生成的文件
      const filelist = Object.keys(compilation.assets)
        .map(filename => `- ${filename}`)
        .join('\n');
      
      // 生成文件列表
      const content = `# 文件列表\n\n${filelist}`;
      
      // 添加到资源中
      compilation.assets[this.filename] = {
        source: () => content,
        size: () => content.length
      };
      
      callback();
    });
  }
}
```

**代码压缩插件**
```javascript
const UglifyJS = require('uglify-js');

class UglifyPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('UglifyPlugin', (compilation) => {
      compilation.hooks.optimizeChunkAssets.tapAsync('UglifyPlugin', (chunks, callback) => {
        chunks.forEach(chunk => {
          chunk.files.forEach(file => {
            if (file.endsWith('.js')) {
              const asset = compilation.assets[file];
              const source = asset.source();
              
              // 压缩代码
              const result = UglifyJS.minify(source);
              
              if (!result.error) {
                compilation.assets[file] = {
                  source: () => result.code,
                  size: () => result.code.length
                };
              }
            }
          });
        });
        
        callback();
      });
    });
  }
}
```

### 5.4 重点

**Q: Plugin和Loader的区别？**
- **Loader**: 文件转换，在模块加载时执行
- **Plugin**: 功能扩展，在构建过程的特定时机执行

**Q: 如何编写一个Plugin？**
1. 创建一个类或函数
2. 实现apply方法
3. 监听compiler或compilation的钩子
4. 在钩子回调中实现功能

## 6. 热更新原理 ⭐⭐⭐⭐

### 6.1 HMR 工作流程

```
文件变化 ──▶ Webpack监听 ──▶ 重新编译 ──▶ 生成更新文件
    │                                        │
    ▼                                        ▼
开发服务器 ──▶ WebSocket通知 ──▶ 客户端接收 ──▶ 模块替换
```

### 6.2 核心实现

**服务端（webpack-dev-server）**
```javascript
const webpack = require('webpack');
const WebSocket = require('ws');

class DevServer {
  constructor(config) {
    this.compiler = webpack(config);
    this.wss = new WebSocket.Server({ port: 8080 });
    
    // 监听文件变化
    this.compiler.hooks.done.tap('DevServer', (stats) => {
      // 发送更新通知
      this.wss.clients.forEach(client => {
        client.send(JSON.stringify({
          type: 'update',
          hash: stats.hash,
          modules: this.getUpdatedModules(stats)
        }));
      });
    });
  }
  
  getUpdatedModules(stats) {
    return stats.compilation.modules
      .filter(module => module.built)
      .map(module => module.id);
  }
}
```

**客户端（HMR Runtime）**
```javascript
class HMRClient {
  constructor() {
    this.ws = new WebSocket('ws://localhost:8080');
    this.currentHash = null;
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'update') {
        this.handleUpdate(data);
      }
    };
  }
  
  handleUpdate(data) {
    if (this.currentHash === data.hash) {
      return; // 没有变化
    }
    
    this.currentHash = data.hash;
    
    // 获取更新的模块
    this.fetchUpdate(data.modules);
  }
  
  fetchUpdate(modules) {
    modules.forEach(moduleId => {
      // 获取新的模块代码
      fetch(`/__webpack_hmr/${moduleId}.js`)
        .then(response => response.text())
        .then(code => {
          // 执行新的模块代码
          this.updateModule(moduleId, code);
        });
    });
  }
  
  updateModule(moduleId, code) {
    // 执行新的模块代码
    const module = eval(code);
    
    // 替换旧模块
    __webpack_require__.cache[moduleId] = module;
    
    // 触发模块更新回调
    if (module.hot && module.hot.accept) {
      module.hot.accept();
    }
  }
}
```

### 6.3 HMR API

```javascript
// 接受自身更新
if (module.hot) {
  module.hot.accept();
}

// 接受依赖更新
if (module.hot) {
  module.hot.accept('./dependency', () => {
    // 依赖更新时的回调
    console.log('依赖模块已更新');
  });
}

// 模块销毁时的清理
if (module.hot) {
  module.hot.dispose((data) => {
    // 清理工作
    clearInterval(timer);
    data.timer = timer;
  });
}
```

### 6.4 重点

**Q: HMR的工作原理？**
1. **文件监听**: Webpack监听文件变化
2. **重新编译**: 生成更新的模块
3. **通知客户端**: 通过WebSocket发送更新信息
4. **获取更新**: 客户端获取新的模块代码
5. **模块替换**: 替换运行时的模块

## 7. 代码分割 ⭐⭐⭐⭐

### 7.1 分割策略

**入口分割**
```javascript
module.exports = {
  entry: {
    main: './src/index.js',
    vendor: './src/vendor.js'
  }
};
```

**动态导入**
```javascript
// 动态导入
import('./module').then(module => {
  module.default();
});

// 使用魔法注释
import(/* webpackChunkName: "my-chunk" */ './module');
```

**SplitChunksPlugin**
```javascript
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all'
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true
        }
      }
    }
  }
};
```

### 7.2 实现原理

```javascript
// 简化的代码分割实现
class SplitChunksPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('SplitChunksPlugin', (compilation) => {
      compilation.hooks.optimizeChunks.tap('SplitChunksPlugin', (chunks) => {
        // 分析模块依赖
        const moduleGroups = this.analyzeModules(chunks);
        
        // 创建新的chunk
        moduleGroups.forEach(group => {
          if (this.shouldSplit(group)) {
            const newChunk = compilation.addChunk(group.name);
            group.modules.forEach(module => {
              newChunk.addModule(module);
            });
          }
        });
      });
    });
  }
  
  analyzeModules(chunks) {
    const groups = new Map();
    
    chunks.forEach(chunk => {
      chunk.getModules().forEach(module => {
        const group = this.getModuleGroup(module);
        if (!groups.has(group.name)) {
          groups.set(group.name, { name: group.name, modules: [] });
        }
        groups.get(group.name).modules.push(module);
      });
    });
    
    return Array.from(groups.values());
  }
  
  shouldSplit(group) {
    return group.modules.length >= this.options.minChunks &&
           group.modules.reduce((size, module) => size + module.size(), 0) >= this.options.minSize;
  }
}
```

### 7.3 考点

**Q: Webpack如何实现代码分割？**
1. **入口分割**: 多个入口点自然分割
2. **动态导入**: import()语法创建分割点
3. **SplitChunksPlugin**: 自动分析和分割公共代码

## 8. Tree Shaking ⭐⭐⭐⭐

### 8.1 基本原理

```javascript
// 源代码
export function usedFunction() {
  return 'used';
}

export function unusedFunction() {
  return 'unused';
}

// 使用
import { usedFunction } from './module';
console.log(usedFunction());

// Tree Shaking后，unusedFunction被移除
```

### 8.2 实现机制

```javascript
// 简化的Tree Shaking实现
class TreeShakingPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('TreeShakingPlugin', (compilation) => {
      compilation.hooks.optimizeModules.tap('TreeShakingPlugin', (modules) => {
        modules.forEach(module => {
          if (module.type === 'javascript/esm') {
            this.shakeModule(module);
          }
        });
      });
    });
  }
  
  shakeModule(module) {
    const ast = module.ast;
    const usedExports = this.getUsedExports(module);
    
    // 移除未使用的导出
    traverse(ast, {
      ExportNamedDeclaration(path) {
        const exportName = path.node.declaration.id.name;
        if (!usedExports.has(exportName)) {
          path.remove();
        }
      }
    });
    
    // 移除未使用的函数和变量
    this.removeUnusedDeclarations(ast, usedExports);
  }
  
  getUsedExports(module) {
    const usedExports = new Set();
    
    // 分析模块的使用情况
    module.dependencies.forEach(dep => {
      if (dep.type === 'import') {
        dep.importedNames.forEach(name => {
          usedExports.add(name);
        });
      }
    });
    
    return usedExports;
  }
}
```

### 8.3 配置要求

```javascript
// package.json
{
  "sideEffects": false // 标记为无副作用
}

// 或者指定有副作用的文件
{
  "sideEffects": [
    "*.css",
    "./src/polyfills.js"
  ]
}

// webpack.config.js
module.exports = {
  mode: 'production', // 启用Tree Shaking
  optimization: {
    usedExports: true,
    sideEffects: false
  }
};
```

### 8.4 重点

**Q: Tree Shaking的原理和条件？**
- **原理**: 基于ES6模块的静态分析，移除未使用的代码
- **条件**: 
  1. 使用ES6模块语法
  2. 生产模式或配置usedExports
  3. 标记sideEffects
  4. 使用支持Tree Shaking的压缩工具

## 9. 性能优化 ⭐⭐⭐⭐⭐

### 9.1 构建性能优化

**缓存优化**
```javascript
module.exports = {
  cache: {
    type: 'filesystem',
    buildDependencies: {
      config: [__filename]
    }
  }
};
```

**并行处理**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'thread-loader',
            options: {
              workers: 2
            }
          },
          'babel-loader'
        ]
      }
    ]
  }
};
```

**减少解析范围**
```javascript
module.exports = {
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')],
    extensions: ['.js', '.json'],
    alias: {
      '@': path.resolve(__dirname, 'src')
    }
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        include: path.resolve(__dirname, 'src'),
        exclude: /node_modules/,
        use: 'babel-loader'
      }
    ]
  }
};
```

### 9.2 运行时性能优化

**代码分割**
```javascript
// 路由级别分割
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));

// 组件级别分割
const HeavyComponent = lazy(() => import('./HeavyComponent'));
```

**资源压缩**
```javascript
const TerserPlugin = require('terser-webpack-plugin');
const CssMinimizerPlugin = require('css-minimizer-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true
          }
        }
      }),
      new CssMinimizerPlugin()
    ]
  }
};
```

**资源优化**
```javascript
module.exports = {
  module: {
    rules: [
      {
        test: /\.(png|jpg|gif)$/,
        use: [
          {
            loader: 'url-loader',
            options: {
              limit: 8192, // 小于8KB的图片转base64
              name: '[name].[hash:8].[ext]',
              outputPath: 'images/'
            }
          }
        ]
      }
    ]
  }
};
```

### 9.3 分析工具

**Bundle分析**
```javascript
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false
    })
  ]
};
```

**构建速度分析**
```javascript
const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
const smp = new SpeedMeasurePlugin();

module.exports = smp.wrap({
  // webpack配置
});
```

### 9.4 重点

**Q: Webpack性能优化策略？**

**构建性能**:
1. 使用缓存（cache）
2. 多进程构建（thread-loader）
3. 减少解析范围（include/exclude）
4. 使用DllPlugin预编译

**运行时性能**:
1. 代码分割（SplitChunks）
2. Tree Shaking
3. 资源压缩
4. 图片优化
5. CDN加速

## 10. 常考算法题 ⭐⭐⭐⭐

### 10.1 简化版Webpack实现

```javascript
class MiniWebpack {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = [];
  }
  
  // 构建依赖图
  buildDependencyGraph(entry) {
    const entryModule = this.createModule(entry);
    const queue = [entryModule];
    
    while (queue.length) {
      const module = queue.shift();
      
      module.dependencies.forEach(depPath => {
        const depModule = this.createModule(depPath);
        module.mapping[depPath] = depModule.id;
        queue.push(depModule);
      });
    }
    
    return entryModule;
  }
  
  // 创建模块
  createModule(filename) {
    const content = fs.readFileSync(filename, 'utf-8');
    const ast = parser.parse(content, {
      sourceType: 'module'
    });
    
    const dependencies = [];
    
    traverse(ast, {
      ImportDeclaration({ node }) {
        dependencies.push(node.source.value);
      }
    });
    
    const { code } = transformFromAst(ast, null, {
      presets: ['@babel/preset-env']
    });
    
    const module = {
      id: this.modules.length,
      filename,
      dependencies,
      code,
      mapping: {}
    };
    
    this.modules.push(module);
    return module;
  }
  
  // 生成bundle
  generateBundle(graph) {
    const moduleMap = this.modules.reduce((acc, module) => {
      acc[module.id] = {
        code: module.code,
        mapping: module.mapping
      };
      return acc;
    }, {});
    
    return `
      (function(modules) {
        const require = (id) => {
          const { code, mapping } = modules[id];
          
          const localRequire = (relativePath) => {
            return require(mapping[relativePath]);
          };
          
          const module = { exports: {} };
          
          (function(require, module, exports) {
            ${code}
          })(localRequire, module, module.exports);
          
          return module.exports;
        };
        
        require(0);
      })(${JSON.stringify(moduleMap)})
    `;
  }
  
  // 运行构建
  run() {
    const graph = this.buildDependencyGraph(this.entry);
    const bundle = this.generateBundle(graph);
    
    fs.writeFileSync(this.output.filename, bundle);
  }
}
```

### 10.2 简化版Loader实现

```javascript
// 简化的loader执行器
class LoaderRunner {
  static runLoaders(options, callback) {
    const { resource, loaders } = options;
    let content = fs.readFileSync(resource, 'utf-8');
    
    // 从右到左执行loader
    const runLoader = (index) => {
      if (index < 0) {
        return callback(null, content);
      }
      
      const loader = loaders[index];
      const loaderContext = {
        resource,
        async: () => {
          return (err, result) => {
            if (err) return callback(err);
            content = result;
            runLoader(index - 1);
          };
        }
      };
      
      try {
        const result = loader.call(loaderContext, content);
        if (result !== undefined) {
          content = result;
          runLoader(index - 1);
        }
      } catch (error) {
        callback(error);
      }
    };
    
    runLoader(loaders.length - 1);
  }
}
```

## 11. 重点总结 ⭐⭐⭐⭐⭐

### 11.1 必掌握概念

1. **核心概念**: Entry、Output、Loader、Plugin
2. **构建流程**: 初始化 → 编译 → 输出
3. **模块解析**: CommonJS、ES6、AMD模块处理
4. **代码分割**: SplitChunks、动态导入
5. **Tree Shaking**: 死代码消除原理
6. **热更新**: HMR工作机制
7. **性能优化**: 构建和运行时优化策略

### 11.2 常见题

**Q1: Webpack的构建流程？**
- 初始化参数，创建Compiler
- 从Entry开始递归解析依赖
- 使用Loader转换文件
- 使用Plugin在特定时机执行任务
- 输出最终的bundle文件

**Q2: Loader和Plugin的区别？**
- Loader: 文件转换器，处理特定类型文件
- Plugin: 功能扩展器，在构建过程中执行特定任务

**Q3: 如何优化Webpack构建性能？**
- 使用缓存、多进程构建
- 减少解析范围
- 使用DllPlugin
- 合理配置resolve

**Q4: Tree Shaking的原理？**
- 基于ES6模块静态分析
- 标记未使用的代码
- 在压缩阶段移除死代码

**Q5: HMR的工作原理？**
- 文件变化触发重新编译
- 通过WebSocket通知客户端
- 客户端获取更新模块
- 运行时替换模块

### 11.3 学习建议

1. **理解核心概念**: 掌握Entry、Output、Loader、Plugin
2. **熟悉构建流程**: 了解从源码到bundle的完整过程
3. **实践配置优化**: 动手配置各种优化策略
4. **阅读源码**: 深入理解核心实现原理
5. **关注新特性**: 跟进Webpack5的新功能

### 11.4 参考资源

- [Webpack官方文档](https://webpack.js.org/)
- [Webpack源码](https://github.com/webpack/webpack)
- [深入浅出Webpack](https://webpack.wuhaolin.cn/)
- [Webpack性能优化指南](https://developers.google.com/web/fundamentals/performance/webpack/)