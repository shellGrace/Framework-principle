# React 核心原理知识点总结

## 1. 虚拟 DOM (Virtual DOM) ⭐⭐⭐⭐⭐

### 核心概念
- **Virtual DOM**: 用 JavaScript 对象描述真实 DOM 结构的抽象表示
- **React Element**: 不可变的普通对象，描述组件实例或 DOM 节点
- **Fiber**: React 16+ 的新协调引擎，可中断的工作单元

### Diff 算法（高频）
- **三大策略**:
  1. 只对同层节点进行比较，跨层级移动视为删除+创建
  2. 不同类型元素会产生不同的树
  3. 通过 key 标识同一层级的子元素
- **Diff 过程**:
  1. 树的比较：逐层比较
  2. 组件比较：类型相同则更新，不同则卸载重建
  3. 元素比较：标签名、属性、子元素
- **key 的重要性**: 帮助 React 识别哪些元素改变了，提高列表渲染性能

## 2. Fiber 架构 ⭐⭐⭐⭐⭐

### 为什么需要 Fiber
- **解决问题**: React 15 的递归调用栈过深，无法中断，造成页面卡顿
- **时间切片**: 将渲染工作分割成小块，在浏览器空闲时执行
- **优先级调度**: 不同更新有不同优先级，高优先级任务可以打断低优先级任务

### Fiber 工作原理
- **双缓存机制**: current tree 和 workInProgress tree
- **工作循环**: beginWork -> completeWork -> commitWork
- **调度器 (Scheduler)**: 管理任务优先级和时间切片
- **协调器 (Reconciler)**: 找出变化的组件
- **渲染器 (Renderer)**: 将变化渲染到宿主环境

### Fiber 节点结构
```javascript
{
  type: 'div',           // 组件类型
  key: null,             // key
  props: {},             // 属性
  stateNode: null,       // 真实 DOM 节点
  child: null,           // 第一个子节点
  sibling: null,         // 下一个兄弟节点
  return: null,          // 父节点
  effectTag: null,       // 副作用标记
  alternate: null        // 对应的另一棵树的节点
}
```

## 3. 生命周期 ⭐⭐⭐⭐

### 类组件生命周期
#### 挂载阶段
1. **constructor()**: 初始化 state，绑定方法
2. **static getDerivedStateFromProps()**: 根据 props 更新 state
3. **render()**: 返回 JSX
4. **componentDidMount()**: 组件挂载后调用，适合发起网络请求

#### 更新阶段
1. **static getDerivedStateFromProps()**
2. **shouldComponentUpdate()**: 性能优化，返回 boolean
3. **render()**
4. **getSnapshotBeforeUpdate()**: 获取更新前的 DOM 信息
5. **componentDidUpdate()**: 组件更新后调用

#### 卸载阶段
- **componentWillUnmount()**: 清理定时器、取消网络请求、清理订阅

#### 错误处理
- **static getDerivedStateFromError()**: 更新 state 使下一次渲染显示降级后的 UI
- **componentDidCatch()**: 记录错误信息

### 函数组件生命周期（Hooks）
- **useEffect()**: 模拟 componentDidMount、componentDidUpdate、componentWillUnmount
- **useLayoutEffect()**: 同步执行，类似 componentDidMount

## 4. Hooks 原理 ⭐⭐⭐⭐⭐

### 核心概念
- **函数组件状态管理**: 让函数组件拥有类组件的能力
- **Hooks 链表**: 每个组件维护一个 hooks 链表
- **闭包**: 利用闭包保存状态

### useState 原理
```javascript
let hookIndex = 0;
let hooks = [];

function useState(initialState) {
  const currentIndex = hookIndex;
  hooks[currentIndex] = hooks[currentIndex] || initialState;
  
  const setState = (newState) => {
    hooks[currentIndex] = newState;
    render(); // 触发重新渲染
  };
  
  hookIndex++;
  return [hooks[currentIndex], setState];
}
```

### useEffect 原理
- **依赖数组**: 浅比较决定是否执行
- **清理函数**: 返回的函数在下次执行前或组件卸载时调用
- **执行时机**: 异步执行，不阻塞浏览器渲染

### Hooks 规则（必问）
1. **只在最顶层调用 Hooks**: 不要在循环、条件或嵌套函数中调用
2. **只在 React 函数中调用 Hooks**: 函数组件或自定义 Hook

### 常用 Hooks
- **useState**: 状态管理
- **useEffect**: 副作用处理
- **useContext**: 消费 Context
- **useReducer**: 复杂状态管理
- **useMemo**: 缓存计算结果
- **useCallback**: 缓存函数
- **useRef**: 获取 DOM 引用或保存可变值

## 5. 状态管理 ⭐⭐⭐⭐

### setState 原理
- **异步更新**: 在事件处理函数中是异步的
- **批量更新**: 多次 setState 会被合并
- **函数式更新**: setState(prevState => newState)
- **回调函数**: setState(newState, callback)

### Context API
- **Provider**: 提供数据
- **Consumer**: 消费数据
- **useContext**: Hook 方式消费
- **性能问题**: Context 值变化会导致所有消费者重新渲染

### 第三方状态管理
- **Redux**: 单向数据流，纯函数 reducer
- **MobX**: 响应式状态管理
- **Zustand**: 轻量级状态管理

## 6. 事件系统 ⭐⭐⭐⭐

### 合成事件 (SyntheticEvent)
- **跨浏览器兼容**: 统一不同浏览器的事件行为
- **事件池**: React 17 之前使用事件池优化性能
- **原生事件包装**: 包装原生事件，提供统一 API

### 事件委托
- **事件绑定**: 所有事件绑定到 document（React 17 改为 root 容器）
- **事件冒泡**: 利用冒泡机制统一处理
- **性能优化**: 减少事件监听器数量

### 事件处理
```javascript
// React 16
document.addEventListener('click', dispatchEvent);

// React 17+
rootContainer.addEventListener('click', dispatchEvent);
```

## 7. 性能优化 ⭐⭐⭐⭐⭐

### 组件优化
- **React.memo()**: 函数组件的 PureComponent
- **PureComponent**: 浅比较 props 和 state
- **shouldComponentUpdate()**: 手动控制更新

### Hooks 优化
- **useMemo()**: 缓存计算结果，避免重复计算
- **useCallback()**: 缓存函数，避免子组件不必要的重新渲染
- **依赖数组**: 正确设置依赖，避免无限循环

### 代码分割
- **React.lazy()**: 动态导入组件
- **Suspense**: 处理异步组件加载
- **路由级别分割**: 按路由分割代码

### 列表优化
- **key 属性**: 正确使用 key，避免使用 index
- **虚拟滚动**: 处理大量数据
- **分页加载**: 避免一次性渲染大量数据

## 8. JSX 原理 ⭐⭐⭐

### JSX 编译
```javascript
// JSX
<div className="container">
  <h1>Hello World</h1>
</div>

// 编译后 (React 17 之前)
React.createElement(
  'div',
  { className: 'container' },
  React.createElement('h1', null, 'Hello World')
);

// 编译后 (React 17+)
import { jsx } from 'react/jsx-runtime';
jsx('div', {
  className: 'container',
  children: jsx('h1', { children: 'Hello World' })
});
```

### createElement 过程
1. 参数处理：type, props, children
2. 创建 React Element 对象
3. 返回不可变的普通对象

## 9. 协调算法 (Reconciliation) ⭐⭐⭐⭐

### Stack Reconciler (React 15)
- **递归处理**: 深度优先遍历
- **同步执行**: 无法中断
- **性能问题**: 大型应用可能造成卡顿

### Fiber Reconciler (React 16+)
- **可中断**: 支持时间切片
- **优先级**: 不同更新有不同优先级
- **并发模式**: 支持并发渲染

### 协调过程
1. **Render 阶段**: 构建 Fiber 树，可中断
2. **Commit 阶段**: 应用变化到 DOM，不可中断

## 10. 并发特性 (Concurrent Features) ⭐⭐⭐

### Concurrent Mode
- **时间切片**: 将工作分解为小块
- **可中断渲染**: 高优先级任务可以打断低优先级任务
- **Suspense**: 处理异步数据获取

### 新特性
- **useTransition()**: 标记非紧急更新
- **useDeferredValue()**: 延迟更新值
- **Suspense for Data Fetching**: 数据获取的 Suspense

## 11. 服务端渲染 (SSR) ⭐⭐⭐

### 核心概念
- **renderToString()**: 将组件渲染为 HTML 字符串
- **hydrate()**: 客户端激活服务端渲染的 HTML
- **同构应用**: 服务端和客户端使用相同代码

### 优势
- **SEO 友好**: 搜索引擎可以抓取内容
- **首屏加载快**: 直接返回 HTML
- **更好的用户体验**: 减少白屏时间

### 挑战
- **服务器压力**: 需要服务器渲染
- **开发复杂度**: 需要考虑服务端和客户端差异
- **状态同步**: 服务端和客户端状态需要同步

## 12. 错误边界 (Error Boundaries) ⭐⭐⭐

### 概念
- **捕获错误**: 捕获子组件树中的 JavaScript 错误
- **显示降级 UI**: 显示备用 UI 而不是崩溃
- **错误日志**: 记录错误信息

### 实现
```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}
```

### 限制
- 不能捕获事件处理器中的错误
- 不能捕获异步代码中的错误
- 不能捕获自身的错误

## 13. 常考算法题

### 手写 useState
```javascript
let state = [];
let setters = [];
let firstRun = true;
let cursor = 0;

function createSetter(cursor) {
  return function setterWithCursor(newVal) {
    state[cursor] = newVal;
    renderWithHooks();
  };
}

function useState(initVal) {
  if (firstRun) {
    state.push(initVal);
    setters.push(createSetter(cursor));
    firstRun = false;
  }
  
  const setter = setters[cursor];
  const value = state[cursor];
  
  cursor++;
  return [value, setter];
}
```

### 手写 useEffect
```javascript
let deps = [];
let hasNoDeps = true;

function useEffect(callback, depArray) {
  const hasChangedDeps = deps
    ? !depArray.every((el, i) => el === deps[i])
    : true;
  
  if (hasChangedDeps || hasNoDeps) {
    callback();
    deps = depArray;
    hasNoDeps = false;
  }
}
```

## 14. 重点总结

### 必须掌握的概念
1. **Virtual DOM 和 Diff 算法**
2. **Fiber 架构和工作原理**
3. **Hooks 原理和使用规则**
4. **生命周期方法**
5. **事件系统和合成事件**
6. **性能优化策略**
7. **setState 的异步更新机制**

### 常见题
1. React 和 Vue 的区别？
2. 为什么需要 Virtual DOM？
3. Fiber 解决了什么问题？
4. Hooks 的实现原理？
5. 如何优化 React 应用性能？
6. setState 是同步还是异步的？
7. React 事件系统的特点？
8. 如何避免组件不必要的重新渲染？

### 学习建议
1. **理论结合实践**: 理解原理的同时多写代码
2. **源码阅读**: 阅读 React 源码加深理解
3. **性能调优**: 学会使用 React DevTools 分析性能
4. **跟进新特性**: 关注 React 的最新发展
5. **项目实战**: 在实际项目中应用所学知识

## 参考资源

- [React 官方文档](https://reactjs.org/)
- [React 源码](https://github.com/facebook/react)
- [React Fiber 架构](https://github.com/acdlite/react-fiber-architecture)
- [React 技术揭秘](https://react.iamkasong.com/)
- [图解 React 原理系列](https://7kms.github.io/react-illustration-series/)