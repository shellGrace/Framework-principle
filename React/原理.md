# React 核心原理深度解析（高级前端工程师面试必备）

## 1. 虚拟 DOM (Virtual DOM) ⭐⭐⭐⭐⭐

### 1.1 核心概念与设计思想
- **Virtual DOM**: 用 JavaScript 对象描述真实 DOM 结构的抽象表示
- **React Element**: 不可变的普通对象，描述组件实例或 DOM 节点
- **设计目标**: 解决频繁操作 DOM 的性能问题，提供声明式编程模型

```javascript
// React Element 结构
const element = {
  type: 'div',
  key: null,
  ref: null,
  props: {
    className: 'container',
    children: [
      {
        type: 'h1',
        props: { children: 'Hello World' }
 ```

### 2.7 优先级调度机制（Lane 模型）

#### Lane 的概念
```javascript
// Lane 是用二进制位表示的优先级模型
const TotalLanes = 31;

// 不同优先级的 Lane
const NoLanes = 0b0000000000000000000000000000000;
const NoLane = 0b0000000000000000000000000000000;

const SyncLane = 0b0000000000000000000000000000001;  // 同步优先级
const InputContinuousHydrationLane = 0b0000000000000000000000000000010;
const InputContinuousLane = 0b0000000000000000000000000000100;  // 连续输入
const DefaultHydrationLane = 0b0000000000000000000000000001000;
const DefaultLane = 0b0000000000000000000000000010000;  // 默认优先级

const TransitionHydrationLane = 0b0000000000000000000000000100000;
const TransitionLanes = 0b0000000001111111111111111000000;  // 过渡优先级

const RetryLanes = 0b0000011110000000000000000000000;  // 重试优先级
const SomeRetryLane = 0b0000010000000000000000000000000;

const SelectiveHydrationLane = 0b0001000000000000000000000000000;

const NonIdleLanes = 0b0001111111111111111111111111111;
const IdleHydrationLane = 0b0010000000000000000000000000000;
const IdleLane = 0b0100000000000000000000000000000;  // 空闲优先级

const OffscreenLane = 0b1000000000000000000000000000000;  // 离屏优先级
```

#### 优先级计算
```javascript
// 根据事件类型获取优先级
function getCurrentUpdatePriority() {
  const currentEvent = window.event;
  if (currentEvent === undefined) {
    return DefaultLane;
  }
  
  return getEventPriority(currentEvent.type);
}

function getEventPriority(domEventName) {
  switch (domEventName) {
    // 离散事件：点击、键盘输入等
    case 'click':
    case 'keydown':
    case 'keyup':
    case 'input':
      return SyncLane;
    
    // 连续事件：滚动、鼠标移动等
    case 'scroll':
    case 'mousemove':
    case 'mouseenter':
    case 'mouseleave':
      return InputContinuousLane;
    
    // 默认事件
    default:
      return DefaultLane;
  }
}

// Lane 操作函数
function getHighestPriorityLane(lanes) {
  return lanes & -lanes;  // 获取最右边的 1
}

function getLowestPriorityLane(lanes) {
  const index = 31 - Math.clz32(lanes);  // 获取最左边的 1
  return index < 0 ? NoLanes : 1 << index;
}

function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}

function isSubsetOfLanes(set, subset) {
  return (set & subset) === subset;
}

function mergeLanes(a, b) {
  return a | b;
}

function removeLanes(set, subset) {
  return set & ~subset;
}
```

#### 调度器实现
```javascript
// 调度器的核心逻辑
function ensureRootIsScheduled(root, currentTime) {
  const existingCallbackNode = root.callbackNode;
  
  // 标记过期的 lanes
  markStarvedLanesAsExpired(root, currentTime);
  
  // 获取下一个要处理的 lanes
  const nextLanes = getNextLanes(
    root,
    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes
  );
  
  if (nextLanes === NoLanes) {
    // 没有工作要做
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
    }
    root.callbackNode = null;
    root.callbackPriority = NoLane;
    return;
  }
  
  // 获取新任务的优先级
  const newCallbackPriority = getHighestPriorityLane(nextLanes);
  const existingCallbackPriority = root.callbackPriority;
  
  // 如果优先级相同，复用现有的调度
  if (newCallbackPriority === existingCallbackPriority) {
    return;
  }
  
  // 取消现有的调度
  if (existingCallbackNode != null) {
    cancelCallback(existingCallbackNode);
  }
  
  // 调度新的任务
  let newCallbackNode;
  if (newCallbackPriority === SyncLane) {
    // 同步任务
    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else {
    // 异步任务
    const schedulerPriorityLevel = lanesToSchedulerPriority(nextLanes);
    newCallbackNode = scheduleCallback(
      schedulerPriorityLevel,
      performConcurrentWorkOnRoot.bind(null, root)
    );
  }
  
  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
}

// 将 Lane 转换为 Scheduler 优先级
function lanesToSchedulerPriority(lanes) {
  if (includesSomeLane(lanes, SyncLane)) {
    return ImmediatePriority;
  }
  if (includesSomeLane(lanes, InputContinuousLane)) {
    return UserBlockingPriority;
  }
  if (includesSomeLane(lanes, DefaultLane)) {
    return NormalPriority;
  }
  if (includesSomeLane(lanes, IdleLane)) {
    return IdlePriority;
  }
  return NormalPriority;
}
```

#### 时间切片实现
```javascript
// 时间切片的核心逻辑
let yieldInterval = 5;  // 5ms 的时间片
let deadline = 0;

function shouldYield() {
  return getCurrentTime() >= deadline;
}

function requestPaint() {
  // 请求浏览器在下一帧绘制
}

// Scheduler 的工作循环
function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);
  
  while (currentTask !== null && !enableSchedulerDebugging) {
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // 当前任务还没过期，但是没有时间了，需要让出控制权
      break;
    }
    
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      
      const continuationCallback = callback(didUserCallbackTimeout);
      currentTime = getCurrentTime();
      
      if (typeof continuationCallback === 'function') {
        // 任务还没完成，继续调度
        currentTask.callback = continuationCallback;
      } else {
        // 任务完成，从队列中移除
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }
      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }
    currentTask = peek(taskQueue);
  }
  
  // 返回是否还有更多工作
  if (currentTask !== null) {
    return true;
  } else {
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

### 2.8 Fiber 的性能优化

#### bailout 策略
```javascript
// 跳过不需要更新的子树
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // 复用 current 的子节点
    workInProgress.child = current.child;
  }
  
  // 检查子节点是否有更新
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // 子节点也不需要更新，直接跳过整个子树
    return null;
  }
  
  // 子节点需要更新，克隆子节点
  cloneChildFibers(current, workInProgress);
  return workInProgress.child;
}

// 组件级别的优化
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  // React.memo 的优化
  if (current !== null) {
    const prevProps = current.memoizedProps;
    if (
      shallowEqual(prevProps, nextProps) &&
      current.ref === workInProgress.ref
    ) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  }
  
  // 执行函数组件
  return updateFunctionComponentInternal(
    current,
    workInProgress,
    Component,
    nextProps,
    renderLanes
  );
}
```

#### 并发特性
```javascript
// startTransition 的实现
function startTransition(callback) {
  const prevTransition = ReactCurrentBatchConfig.transition;
  ReactCurrentBatchConfig.transition = {};
  
  try {
    callback();
  } finally {
    ReactCurrentBatchConfig.transition = prevTransition;
  }
}

// useDeferredValue 的实现
function useDeferredValue(value) {
  const [prevValue, setValue] = useState(value);
  
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      startTransition(() => {
        setValue(value);
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [value]);
  
  return prevValue;
}
      }
    ]
  },
  _owner: null,
  _store: {}
};
```

### 1.2 Virtual DOM 的优势
1. **性能优化**: 批量更新，减少 DOM 操作
2. **跨平台**: 抽象层可以渲染到不同平台
3. **可预测性**: 函数式编程，状态可预测
4. **开发体验**: 声明式编程，易于理解和维护

### 1.3 Diff 算法详解（面试重点）

#### 三大核心策略
1. **Tree Diff**: 只对同层节点进行比较，跨层级移动视为删除+创建
2. **Component Diff**: 不同类型元素会产生不同的树
3. **Element Diff**: 通过 key 标识同一层级的子元素

#### Diff 算法源码实现原理
```javascript
// 简化版 Diff 算法
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current === null) {
    // 首次渲染
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren
    );
  } else {
    // 更新渲染
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren
    );
  }
}

// 协调子节点
function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
  // 处理单个节点
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild
          )
        );
    }
  }
  
  // 处理数组（多个子节点）
  if (Array.isArray(newChild)) {
    return reconcileChildrenArray(
      returnFiber,
      currentFirstChild,
      newChild
    );
  }
  
  // 删除剩余的子节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

#### 单节点 Diff
```javascript
function reconcileSingleElement(returnFiber, currentFirstChild, element) {
  const key = element.key;
  let child = currentFirstChild;
  
  while (child !== null) {
    // key 相同
    if (child.key === key) {
      // type 也相同，可以复用
      if (child.elementType === element.type) {
        deleteRemainingChildren(returnFiber, child.sibling);
        const existing = useFiber(child, element.props);
        existing.ref = coerceRef(returnFiber, child, element);
        existing.return = returnFiber;
        return existing;
      } else {
        // key 相同但 type 不同，删除所有子节点
        deleteRemainingChildren(returnFiber, child);
        break;
      }
    } else {
      // key 不同，删除该节点
      deleteChild(returnFiber, child);
    }
    child = child.sibling;
  }
  
  // 创建新节点
  const created = createFiberFromElement(element, returnFiber.mode);
  created.ref = coerceRef(returnFiber, currentFirstChild, element);
  created.return = returnFiber;
  return created;
}
```

#### 多节点 Diff（最复杂的情况）
```javascript
function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren) {
  let resultingFirstChild = null;
  let previousNewFiber = null;
  let oldFiber = currentFirstChild;
  let lastPlacedIndex = 0;
  let newIdx = 0;
  let nextOldFiber = null;
  
  // 第一轮遍历：处理更新的节点
  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
    if (oldFiber.index > newIdx) {
      nextOldFiber = oldFiber;
      oldFiber = null;
    } else {
      nextOldFiber = oldFiber.sibling;
    }
    
    const newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx]);
    
    if (newFiber === null) {
      if (oldFiber === null) {
        oldFiber = nextOldFiber;
      }
      break;
    }
    
    if (shouldTrackSideEffects) {
      if (oldFiber && newFiber.alternate === null) {
        deleteChild(returnFiber, oldFiber);
      }
    }
    
    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
    
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    
    previousNewFiber = newFiber;
    oldFiber = nextOldFiber;
  }
  
  // 新节点遍历完，删除剩余的老节点
  if (newIdx === newChildren.length) {
    deleteRemainingChildren(returnFiber, oldFiber);
    return resultingFirstChild;
  }
  
  // 老节点遍历完，创建剩余的新节点
  if (oldFiber === null) {
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx]);
      if (newFiber === null) continue;
      
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      
      previousNewFiber = newFiber;
    }
    return resultingFirstChild;
  }
  
  // 将剩余的老节点加入到 Map 中
  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
  
  // 第二轮遍历：处理移动、新增、删除
  for (; newIdx < newChildren.length; newIdx++) {
    const newFiber = updateFromMap(
      existingChildren,
      returnFiber,
      newIdx,
      newChildren[newIdx]
    );
    
    if (newFiber !== null) {
      if (shouldTrackSideEffects) {
        if (newFiber.alternate !== null) {
          existingChildren.delete(
            newFiber.key === null ? newIdx : newFiber.key
          );
        }
      }
      
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      
      previousNewFiber = newFiber;
    }
  }
  
  // 删除 Map 中剩余的节点
  if (shouldTrackSideEffects) {
    existingChildren.forEach(child => deleteChild(returnFiber, child));
  }
  
  return resultingFirstChild;
}
```

### 1.4 key 的深度理解（高频面试题）

#### key 的作用机制
```javascript
// 错误示例：使用 index 作为 key
const BadExample = ({ items }) => {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>
          <input type="text" />
          {item.name}
        </li>
      ))}
    </ul>
  );
};

// 正确示例：使用唯一标识作为 key
const GoodExample = ({ items }) => {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          <input type="text" />
          {item.name}
        </li>
      ))}
    </ul>
  );
};
```

#### key 的性能影响分析
```javascript
// 场景：在列表头部插入新元素
// 原列表：[A, B, C]
// 新列表：[D, A, B, C]

// 使用 index 作为 key 的 Diff 过程：
// key=0: D vs A (不同，更新)
// key=1: A vs B (不同，更新)
// key=2: B vs C (不同，更新)
// key=3: C vs undefined (新增)
// 结果：4 次操作

// 使用唯一 ID 作为 key 的 Diff 过程：
// key=D: 新增
// key=A: 复用
// key=B: 复用
// key=C: 复用
// 结果：1 次操作
```

## 2. Fiber 架构 ⭐⭐⭐⭐⭐

### 2.1 为什么需要 Fiber（面试必问）
### 为什么需要 Fiber
- **解决问题**: React 15 的递归调用栈过深，无法中断，造成页面卡顿
- **时间切片**: 将渲染工作分割成小块，在浏览器空闲时执行
- **优先级调度**: 不同更新有不同优先级，高优先级任务可以打断低优先级任务

### Fiber 工作原理
- **双缓存机制**: current tree 和 workInProgress tree
- **工作循环**: beginWork -> completeWork -> commitWork
- **调度器 (Scheduler)**: 管理任务优先级和时间切片
- **协调器 (Reconciler)**: 找出变化的组件
- **渲染器 (Renderer)**: 将变化渲染到宿主环境
#### React 15 的问题
```javascript
// React 15 的递归调用栈
function reconcileChildren(element) {
  // 递归处理子节点
  element.children.forEach(child => {
    reconcileChildren(child); // 无法中断的递归
  });
  // 更新 DOM
  updateDOM(element);
}
```

**问题分析**：
1. **调用栈过深**: 大型组件树导致递归层级过深
2. **无法中断**: 一旦开始更新，必须完成整个树的遍历
3. **阻塞主线程**: 长时间占用主线程，导致页面卡顿
4. **用户体验差**: 动画、输入响应延迟

#### Fiber 的解决方案
1. **时间切片 (Time Slicing)**: 将渲染工作分割成小块
2. **可中断渲染**: 高优先级任务可以打断低优先级任务
3. **优先级调度**: 不同更新有不同优先级
4. **并发模式**: 支持并发渲染

### 2.2 Fiber 架构设计

#### 三层架构
```javascript
// 1. Scheduler（调度器）- 调度任务的优先级
function scheduleWork(fiber, expirationTime) {
  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);
  if (root !== null) {
    ensureRootIsScheduled(root, currentTime);
  }
}

// 2. Reconciler（协调器）- 找出变化的组件
function workLoop() {
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}

// 3. Renderer（渲染器）- 将变化渲染到宿主环境
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  commitBeforeMutationEffects();
  commitMutationEffects(finishedWork);
  commitLayoutEffects(finishedWork);
}
```

### 2.3 Fiber 节点结构详解

```javascript
// Fiber 节点的完整结构
function FiberNode(tag, pendingProps, key, mode) {
  // 实例属性
  this.tag = tag;                    // 节点类型
  this.key = key;                    // key
  this.elementType = null;           // 元素类型
  this.type = null;                  // 组件类型
  this.stateNode = null;             // 真实 DOM 节点或组件实例
  
  // Fiber 树结构
  this.return = null;                // 父节点
  this.child = null;                 // 第一个子节点
  this.sibling = null;               // 下一个兄弟节点
  this.index = 0;                    // 在父节点中的索引
  
  this.ref = null;                   // ref
  
  // 工作单元属性
  this.pendingProps = pendingProps;  // 新的 props
  this.memoizedProps = null;         // 上次渲染的 props
  this.updateQueue = null;           // 更新队列
  this.memoizedState = null;         // 上次渲染的 state
  this.dependencies = null;          // 依赖列表
  
  this.mode = mode;                  // 模式
  
  // 副作用
  this.flags = NoFlags;              // 副作用标记
  this.subtreeFlags = NoFlags;       // 子树副作用标记
  this.deletions = null;             // 要删除的子节点
  
  // 调度相关
  this.lanes = NoLanes;              // 优先级
  this.childLanes = NoLanes;         // 子节点优先级
  
  // 双缓存
  this.alternate = null;             // 对应的另一棵树的节点
}
```

### 2.4 双缓存机制（Double Buffering）

```javascript
// 双缓存树的切换
function commitRoot(root) {
  // 获取新构建的 Fiber 树
  const finishedWork = root.finishedWork;
  
  // 执行 DOM 操作
  commitMutationEffects(finishedWork);
  
  // 切换 current 指针
  root.current = finishedWork;
  
  // 执行 layout effects
  commitLayoutEffects(finishedWork);
}

// current tree 和 workInProgress tree 的关系
function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  
  if (workInProgress === null) {
    // 首次创建
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    
    // 建立双向连接
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 复用已有节点
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    
    // 重置副作用
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }
  
  // 复制其他属性
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  
  return workInProgress;
}
```

### 2.5 Fiber 工作循环

#### Render 阶段（可中断）
```javascript
// 工作循环的核心逻辑
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  
  // beginWork: 向下遍历
  let next = beginWork(current, unitOfWork, subtreeRenderLanes);
  
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  if (next === null) {
    // 没有子节点，开始 completeWork
    completeUnitOfWork(unitOfWork);
  } else {
    // 有子节点，继续处理子节点
    workInProgress = next;
  }
}

function completeUnitOfWork(unitOfWork) {
  let completedWork = unitOfWork;
  
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;
    
    // completeWork: 向上归并
    const next = completeWork(current, completedWork, subtreeRenderLanes);
    
    if (next !== null) {
      workInProgress = next;
      return;
    }
    
    // 处理兄弟节点
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    
    // 回到父节点
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
```

#### beginWork 详解
```javascript
function beginWork(current, workInProgress, renderLanes) {
  const updateLanes = workInProgress.lanes;
  
  // 优化：如果 props 和 context 没有变化，可以复用
  if (current !== null) {
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    
    if (oldProps !== newProps || hasLegacyContextChanged()) {
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false;
      // 跳过这个节点和它的子树
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  }
  
  // 清除 lanes
  workInProgress.lanes = NoLanes;
  
  // 根据节点类型进行不同的处理
  switch (workInProgress.tag) {
    case FunctionComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps = workInProgress.elementType === Component
        ? unresolvedProps
        : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes
      );
    }
    case ClassComponent: {
      const Component = workInProgress.type;
      const unresolvedProps = workInProgress.pendingProps;
      const resolvedProps = workInProgress.elementType === Component
        ? unresolvedProps
        : resolveDefaultProps(Component, unresolvedProps);
      return updateClassComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes
      );
    }
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    // ... 其他类型
  }
}
```

#### completeWork 详解
```javascript
function completeWork(current, workInProgress, renderLanes) {
  const newProps = workInProgress.pendingProps;
  
  switch (workInProgress.tag) {
    case HostComponent: {
      const rootContainerInstance = getRootHostContainer();
      const type = workInProgress.type;
      
      if (current !== null && workInProgress.stateNode != null) {
        // 更新阶段
        updateHostComponent(
          current,
          workInProgress,
          type,
          newProps,
          rootContainerInstance
        );
      } else {
        // 挂载阶段
        const instance = createInstance(
          type,
          newProps,
          rootContainerInstance,
          currentHostContext,
          workInProgress
        );
        
        // 将子节点插入到新创建的实例中
        appendAllChildren(instance, workInProgress, false, false);
        
        workInProgress.stateNode = instance;
        
        // 处理 props
        if (finalizeInitialChildren(
          instance,
          type,
          newProps,
          rootContainerInstance,
          currentHostContext
        )) {
          markUpdate(workInProgress);
        }
      }
      return null;
    }
    case FunctionComponent:
    case ClassComponent:
    case HostRoot:
      // 这些类型在 completeWork 中通常不需要特殊处理
      return null;
  }
}
```

### 2.6 Commit 阶段（不可中断）

```javascript
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  const lanes = root.finishedLanes;
  
  // 三个子阶段
  
  // 1. before mutation 阶段
  commitBeforeMutationEffects(root, finishedWork);
  
  // 2. mutation 阶段
  commitMutationEffects(root, finishedWork, lanes);
  
  // 切换 current 指针
  root.current = finishedWork;
  
  // 3. layout 阶段
  commitLayoutEffects(finishedWork, root, lanes);
}

// before mutation 阶段：执行 DOM 操作前
function commitBeforeMutationEffects(root, firstChild) {
  let fiber = firstChild;
  while (fiber !== null) {
    if (fiber.child !== null && (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags) {
      commitBeforeMutationEffects(root, fiber.child);
    }
    
    if ((fiber.flags & BeforeMutationMask) !== NoFlags) {
      commitBeforeMutationEffectsOnFiber(fiber);
    }
    
    fiber = fiber.sibling;
  }
}

// mutation 阶段：执行 DOM 操作
function commitMutationEffects(root, firstChild, lanes) {
  let fiber = firstChild;
  while (fiber !== null) {
    if (fiber.child !== null && (fiber.subtreeFlags & MutationMask) !== NoFlags) {
      commitMutationEffects(root, fiber.child, lanes);
    }
    
    if ((fiber.flags & MutationMask) !== NoFlags) {
      commitMutationEffectsOnFiber(fiber, root);
    }
    
    fiber = fiber.sibling;
  }
}

// layout 阶段：执行 DOM 操作后
function commitLayoutEffects(finishedWork, root, committedLanes) {
  let fiber = finishedWork;
  while (fiber !== null) {
    if (fiber.child !== null && (fiber.subtreeFlags & LayoutMask) !== NoFlags) {
      commitLayoutEffects(fiber.child, root, committedLanes);
    }
    
    if ((fiber.flags & LayoutMask) !== NoFlags) {
      commitLayoutEffectOnFiber(root, fiber.alternate, fiber, committedLanes);
    }
    
    fiber = fiber.sibling;
  }
}
```

## 3. 生命周期 ⭐⭐⭐⭐

### 类组件生命周期
#### 挂载阶段
1. **constructor()**: 初始化 state，绑定方法
2. **static getDerivedStateFromProps()**: 根据 props 更新 state
3. **render()**: 返回 JSX
4. **componentDidMount()**: 组件挂载后调用，适合发起网络请求

#### 更新阶段
1. **static getDerivedStateFromProps()**
2. **shouldComponentUpdate()**: 性能优化，返回 boolean
3. **render()**
4. **getSnapshotBeforeUpdate()**: 获取更新前的 DOM 信息
5. **componentDidUpdate()**: 组件更新后调用

#### 卸载阶段
- **componentWillUnmount()**: 清理定时器、取消网络请求、清理订阅

#### 错误处理
- **static getDerivedStateFromError()**: 更新 state 使下一次渲染显示降级后的 UI
- **componentDidCatch()**: 记录错误信息

### 函数组件生命周期（Hooks）
- **useEffect()**: 模拟 componentDidMount、componentDidUpdate、componentWillUnmount
- **useLayoutEffect()**: 同步执行，类似 componentDidMount

## 4. Hooks 原理 ⭐⭐⭐⭐⭐

### 4.1 Hooks 的数据结构

#### Hook 对象结构
```javascript
// Hook 对象的基本结构
type Hook = {
  memoizedState: any,      // 当前状态值
  baseState: any,          // 基础状态值
  baseQueue: Update<any, any> | null,  // 基础更新队列
  queue: UpdateQueue<any, any> | null, // 更新队列
  next: Hook | null,       // 下一个 Hook
};

// 更新队列结构
type UpdateQueue<S, A> = {
  pending: Update<S, A> | null,  // 待处理的更新
  dispatch: Dispatch<A> | null,  // dispatch 函数
  lastRenderedReducer: ((S, A) => S) | null,  // 上次渲染的 reducer
  lastRenderedState: S,          // 上次渲染的状态
};

// 更新对象结构
type Update<S, A> = {
  lane: Lane,              // 优先级
  action: A,               // 更新动作
  eagerReducer: ((S, A) => S) | null,  // 预计算的 reducer
  eagerState: S,           // 预计算的状态
  next: Update<S, A>,      // 下一个更新
  priority?: ReactPriorityLevel,  // React 优先级
};
```

#### Hooks 链表管理
```javascript
// 当前正在渲染的 Fiber 节点
let currentlyRenderingFiber = null;
// 当前 Hook 索引
let currentHookNameInDev = null;
// 工作中的 Hook
let workInProgressHook = null;
// 当前 Hook
let currentHook = null;

// 挂载阶段的 Hook 创建
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  
  if (workInProgressHook === null) {
    // 第一个 Hook
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // 后续 Hook，添加到链表末尾
    workInProgressHook = workInProgressHook.next = hook;
  }
  
  return workInProgressHook;
}

// 更新阶段的 Hook 获取
function updateWorkInProgressHook() {
  let nextCurrentHook;
  
  if (currentHook === null) {
    // 第一个 Hook
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    // 后续 Hook
    nextCurrentHook = currentHook.next;
  }
  
  let nextWorkInProgressHook;
  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }
  
  if (nextWorkInProgressHook !== null) {
    // 复用已有的 Hook
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // 克隆 Hook
    currentHook = nextCurrentHook;
    
    const newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null,
    };
    
    if (workInProgressHook === null) {
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  
  return workInProgressHook;
}
```

### 4.2 useState 深度解析

#### useState 的实现
```javascript
// useState 的挂载实现
function mountState(initialState) {
  const hook = mountWorkInProgressHook();
  
  if (typeof initialState === 'function') {
    initialState = initialState();
  }
  
  hook.memoizedState = hook.baseState = initialState;
  
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState,
  });
  
  const dispatch = (queue.dispatch = dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue
  ));
  
  return [hook.memoizedState, dispatch];
}

// useState 的更新实现
function updateState(initialState) {
  return updateReducer(basicStateReducer, initialState);
}

// 基础状态 reducer
function basicStateReducer(state, action) {
  return typeof action === 'function' ? action(state) : action;
}

// dispatch 动作的实现
function dispatchAction(fiber, queue, action) {
  const eventTime = requestEventTime();
  const lane = requestUpdateLane(fiber);
  
  const update = {
    lane,
    action,
    eagerReducer: null,
    eagerState: null,
    next: null,
  };
  
  // 尝试预计算状态（eager evaluation）
  if (fiber === currentlyRenderingFiber || (fiber.alternate === currentlyRenderingFiber)) {
    // 渲染阶段的更新
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (
      fiber.lanes === NoLanes &&
      (fiber.alternate === null || fiber.alternate.lanes === NoLanes)
    ) {
      // 当前 Fiber 没有待处理的更新，可以预计算
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        try {
          const currentState = queue.lastRenderedState;
          const eagerState = lastRenderedReducer(currentState, action);
          
          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;
          
          if (Object.is(eagerState, currentState)) {
            // 状态没有变化，跳过更新
            return;
          }
        } catch (error) {
          // 预计算失败，继续正常流程
        }
      }
    }
    
    // 将更新加入队列
    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}

// 将更新加入队列
function enqueueUpdate(fiber, update) {
  const updateQueue = fiber.updateQueue;
  if (updateQueue === null) {
    return;
  }
  
  const sharedQueue = updateQueue.shared;
  const pending = sharedQueue.pending;
  
  if (pending === null) {
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }
  
  sharedQueue.pending = update;
}
```

#### useState 的批量更新
```javascript
// 批量更新的实现
function batchedUpdates(fn, a) {
  const prevExecutionContext = executionContext;
  executionContext |= BatchedContext;
  
  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;
    if (executionContext === NoContext) {
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}

// 自动批处理（React 18）
function createRoot(container, options) {
  const root = createContainer(container, ConcurrentRoot, options);
  
  return {
    render(children) {
      updateContainer(children, root, null, null);
    },
    unmount() {
      updateContainer(null, root, null, null);
    }
  };
}

// 示例：多个 setState 的批量处理
function handleClick() {
  // 这些更新会被批量处理
  setCount(c => c + 1);
  setFlag(f => !f);
  setName('new name');
  
  // 在 React 18 中，即使在 setTimeout 中也会批量处理
  setTimeout(() => {
    setCount(c => c + 1);
    setFlag(f => !f);
  }, 1000);
}
```

### 4.3 useEffect 深度解析

#### useEffect 的数据结构
```javascript
// Effect 对象结构
type Effect = {
  tag: HookFlags,          // 副作用标记
  create: () => (() => void) | void,  // 创建函数
  destroy: (() => void) | void,       // 销毁函数
  deps: Array<mixed> | null,          // 依赖数组
  next: Effect,            // 下一个 Effect
};

// Effect Hook 结构
type EffectHook = {
  memoizedState: Effect,   // 当前 Effect
  baseState: null,
  baseQueue: null,
  queue: null,
  next: Hook | null,
};
```

#### useEffect 的实现
```javascript
// useEffect 的挂载实现
function mountEffect(create, deps) {
  return mountEffectImpl(
    UpdateEffect | PassiveEffect,
    HookPassive,
    create,
    deps
  );
}

// useLayoutEffect 的挂载实现
function mountLayoutEffect(create, deps) {
  return mountEffectImpl(
    UpdateEffect,
    HookLayout,
    create,
    deps
  );
}

// Effect 实现的通用逻辑
function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  
  currentlyRenderingFiber.flags |= fiberFlags;
  
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    undefined,
    nextDeps
  );
}

// useEffect 的更新实现
function updateEffect(create, deps) {
  return updateEffectImpl(
    UpdateEffect | PassiveEffect,
    HookPassive,
    create,
    deps
  );
}

function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  let destroy = undefined;
  
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 依赖没有变化，跳过执行
        pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }
  
  currentlyRenderingFiber.flags |= fiberFlags;
  
  hook.memoizedState = pushEffect(
    HookHasEffect | hookFlags,
    create,
    destroy,
    nextDeps
  );
}

// 推入 Effect 到链表
function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue;
  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  
  return effect;
}

// 依赖比较
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    return false;
  }
  
  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (Object.is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  
  return true;
}
```

#### useEffect 的执行时机
```javascript
// commit 阶段执行 Effect
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  
  // before mutation 阶段
  commitBeforeMutationEffects(root, finishedWork);
  
  // mutation 阶段
  commitMutationEffects(root, finishedWork);
  
  // 切换 current 指针
  root.current = finishedWork;
  
  // layout 阶段（同步执行 useLayoutEffect）
  commitLayoutEffects(finishedWork, root);
  
  // 调度 useEffect（异步执行）
  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags ||
      (finishedWork.flags & PassiveMask) !== NoFlags) {
    if (!rootDoesHavePassiveEffects) {
      rootDoesHavePassiveEffects = true;
      scheduleCallback(NormalSchedulerPriority, () => {
        flushPassiveEffects();
        return null;
      });
    }
  }
}

// 执行被动副作用（useEffect）
function flushPassiveEffects() {
  if (rootWithPendingPassiveEffects !== null) {
    const root = rootWithPendingPassiveEffects;
    rootWithPendingPassiveEffects = null;
    pendingPassiveEffectsLanes = NoLanes;
    
    const prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    
    // 执行销毁函数
    commitPassiveUnmountEffects(root.current);
    
    // 执行创建函数
    commitPassiveMountEffects(root, root.current);
    
    executionContext = prevExecutionContext;
  }
}
```

### 4.4 其他重要 Hooks

#### useReducer 实现
```javascript
function mountReducer(reducer, initialArg, init) {
  const hook = mountWorkInProgressHook();
  let initialState;
  
  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }
  
  hook.memoizedState = hook.baseState = initialState;
  
  const queue = (hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState,
  });
  
  const dispatch = (queue.dispatch = dispatchAction.bind(
    null,
    currentlyRenderingFiber,
    queue
  ));
  
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  
  queue.lastRenderedReducer = reducer;
  
  const current = currentHook;
  let baseQueue = current.baseQueue;
  
  const pendingQueue = queue.pending;
  if (pendingQueue !== null) {
    if (baseQueue !== null) {
      const baseFirst = baseQueue.next;
      const pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }
    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }
  
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let newState = current.baseState;
    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;
    let update = first;
    
    do {
      const updateLane = update.lane;
      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // 优先级不够，跳过这个更新
        const clone = {
          lane: updateLane,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null,
        };
        
        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        
        currentlyRenderingFiber.lanes = mergeLanes(
          currentlyRenderingFiber.lanes,
          updateLane
        );
      } else {
        // 优先级足够，处理这个更新
        if (newBaseQueueLast !== null) {
          const clone = {
            lane: NoLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null,
          };
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        
        if (update.eagerReducer === reducer) {
          newState = update.eagerState;
        } else {
          const action = update.action;
          newState = reducer(newState, action);
        }
      }
      
      update = update.next;
    } while (update !== null && update !== first);
    
    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    }
    
    if (!Object.is(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }
    
    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    
    queue.lastRenderedState = newState;
  }
  
  return [hook.memoizedState, queue.dispatch];
}
```

#### useMemo 和 useCallback 实现
```javascript
// useMemo 的实现
function mountMemo(nextCreate, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

// useCallback 的实现
function mountCallback(callback, deps) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  
  hook.memoizedState = [callback, nextDeps];
  return callback;
}
```

### 4.5 Hooks 规则的技术原理

#### 为什么不能在条件语句中使用 Hooks
```javascript
// 错误示例
function BadComponent({ condition }) {
  const [count, setCount] = useState(0);
  
  if (condition) {
    const [name, setName] = useState('');  // ❌ 违反 Hooks 规则
  }
  
  const [flag, setFlag] = useState(false);
  
  return <div>{count}</div>;
}

// 问题分析：
// 第一次渲染（condition = true）：
// Hook 0: count
// Hook 1: name
// Hook 2: flag

// 第二次渲染（condition = false）：
// Hook 0: count
// Hook 1: flag  // ❌ 期望是 name，实际是 flag

// 正确示例
function GoodComponent({ condition }) {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  const [flag, setFlag] = useState(false);
  
  // 在渲染逻辑中处理条件
  return (
    <div>
      {count}
      {condition && <input value={name} onChange={e => setName(e.target.value)} />}
      {flag && <span>Flag is true</span>}
    </div>
  );
}
```

#### Hooks 调用顺序的检测
```javascript
// React 开发模式下的 Hooks 检测
function checkDepsAreArrayDev(deps) {
  if (deps !== undefined && deps !== null && !Array.isArray(deps)) {
    console.error(
      '%s received a final argument that is not an array (instead, received `%s`). ' +
      'When specified, the final argument must be an array.',
      currentHookNameInDev,
      typeof deps
    );
  }
}

function warnOnHookMismatchInDev(currentHookName) {
  const componentName = getComponentName(currentlyRenderingFiber.type);
  if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
    didWarnAboutMismatchedHooksForComponent.add(componentName);
    
    if (hookTypesDev !== null) {
      let table = '';
      
      for (let i = 0; i <= hookTypesUpdateIndexDev; i++) {
        const oldHookName = hookTypesDev[i];
        const newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
        
        table += `${i + 1}. ${oldHookName} -> ${newHookName}\n`;
      }
      
      console.error(
        'React has detected a change in the order of Hooks called by %s. ' +
        'This will lead to bugs and errors if not fixed. ' +
        'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' +
        '   Previous render            Next render\n' +
        '   ------------------------------------------------------\n' +
        '%s' +
        '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',
        componentName,
        table
      );
    }
  }
}
```

## 5. 状态管理 ⭐⭐⭐⭐

### 5.1 setState 深度解析

#### setState 的工作原理
```javascript
// setState 的基本实现
Component.prototype.setState = function(partialState, callback) {
  // 创建更新对象
  const update = {
    payload: partialState,
    callback: callback,
    next: null,
  };
  
  // 将更新加入队列
  enqueueUpdate(this._reactInternalFiber, update);
  
  // 调度更新
  scheduleWork(this._reactInternalFiber, expirationTime);
};

// 更新队列的处理
function processUpdateQueue(workInProgress, queue, props, instance) {
  let newState = workInProgress.memoizedState;
  let update = queue.first;
  
  // 遍历更新队列
  while (update !== null) {
    newState = getStateFromUpdate(
      workInProgress,
      queue,
      update,
      newState,
      props,
      instance
    );
    
    // 处理回调
    if (update.callback !== null) {
      workInProgress.effectTag |= Callback;
      update.nextEffect = null;
      if (queue.lastEffect === null) {
        queue.firstEffect = queue.lastEffect = update;
      } else {
        queue.lastEffect.nextEffect = update;
        queue.lastEffect = update;
      }
    }
    
    update = update.next;
  }
  
  return newState;
}

// 从更新对象获取新状态
function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState: {
      const payload = update.payload;
      if (typeof payload === 'function') {
        return payload.call(instance, prevState, nextProps);
      }
      return payload;
    }
    case CaptureUpdate: {
      workInProgress.effectTag = (workInProgress.effectTag & ~ShouldCapture) | DidCapture;
    }
    case UpdateState: {
      const payload = update.payload;
      let partialState;
      if (typeof payload === 'function') {
        partialState = payload.call(instance, prevState, nextProps);
      } else {
        partialState = payload;
      }
      if (partialState === null || partialState === undefined) {
        return prevState;
      }
      return Object.assign({}, prevState, partialState);
    }
  }
  return prevState;
}
```

#### setState 的异步性质
```javascript
// React 18 之前的批量更新
class Counter extends React.Component {
  state = { count: 0 };
  
  handleClick = () => {
    console.log('Before setState:', this.state.count); // 0
    
    // 这些 setState 会被批量处理
    this.setState({ count: this.state.count + 1 });
    this.setState({ count: this.state.count + 1 });
    this.setState({ count: this.state.count + 1 });
    
    console.log('After setState:', this.state.count); // 仍然是 0
    
    // 使用函数式更新确保正确的累加
    this.setState(prevState => ({ count: prevState.count + 1 }));
    this.setState(prevState => ({ count: prevState.count + 1 }));
    this.setState(prevState => ({ count: prevState.count + 1 }));
  };
  
  handleAsyncClick = () => {
    // 在异步操作中，setState 是同步的（React 18 之前）
    setTimeout(() => {
      console.log('Before async setState:', this.state.count);
      this.setState({ count: this.state.count + 1 });
      console.log('After async setState:', this.state.count); // 立即更新
    }, 0);
  };
}
```

#### React 18 的自动批处理
```javascript
// React 18 中所有更新都会被自动批处理
function App() {
  const [count, setCount] = useState(0);
  const [flag, setFlag] = useState(false);
  
  function handleClick() {
    // React 18 中这些更新会被批处理
    setCount(c => c + 1);
    setFlag(f => !f);
    // 只会触发一次重新渲染
  }
  
  function handleAsyncClick() {
    // React 18 中异步操作也会被批处理
    setTimeout(() => {
      setCount(c => c + 1);
      setFlag(f => !f);
      // 只会触发一次重新渲染
    }, 1000);
  }
  
  function handleSyncClick() {
    // 如果需要同步更新，使用 flushSync
    flushSync(() => {
      setCount(c => c + 1);
    });
    // 立即重新渲染
    flushSync(() => {
      setFlag(f => !f);
    });
    // 再次立即重新渲染
  }
}
```

### 5.2 Context API 深度解析

#### Context 的实现原理
```javascript
// createContext 的实现
function createContext(defaultValue) {
  const context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue, // 用于并发模式
    _threadCount: 0,
    Provider: null,
    Consumer: null,
  };
  
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context,
  };
  
  context.Consumer = context;
  
  return context;
}

// Provider 组件的实现
function updateContextProvider(current, workInProgress, renderLanes) {
  const providerType = workInProgress.type;
  const context = providerType._context;
  const newProps = workInProgress.pendingProps;
  const oldProps = workInProgress.memoizedProps;
  const newValue = newProps.value;
  
  // 推入新的 context 值
  pushProvider(workInProgress, newValue);
  
  if (oldProps !== null) {
    const oldValue = oldProps.value;
    const changedBits = calculateChangedBits(context, newValue, oldValue);
    
    if (changedBits === 0) {
      // 值没有变化，可以跳过子树的更新
      if (oldProps.children === newProps.children && !hasLegacyContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
    } else {
      // 值发生变化，需要传播更新
      propagateContextChange(workInProgress, context, changedBits, renderLanes);
    }
  }
  
  const newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

// 传播 Context 变化
function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
  let fiber = workInProgress.child;
  if (fiber !== null) {
    fiber.return = workInProgress;
  }
  
  while (fiber !== null) {
    let nextFiber;
    
    // 检查当前 fiber 是否消费了这个 context
    const list = fiber.dependencies;
    if (list !== null) {
      nextFiber = fiber.child;
      
      let dependency = list.firstContext;
      while (dependency !== null) {
        if (
          dependency.context === context &&
          (dependency.observedBits & changedBits) !== 0
        ) {
          // 找到了消费者，标记需要更新
          if (fiber.tag === ClassComponent) {
            const update = createUpdate(renderLanes, null);
            update.tag = ForceUpdate;
            enqueueUpdate(fiber, update);
          }
          
          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
          const alternate = fiber.alternate;
          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
          }
          
          scheduleWorkOnParentPath(fiber.return, renderLanes);
          
          list.lanes = mergeLanes(list.lanes, renderLanes);
          break;
        }
        dependency = dependency.next;
      }
    }
    
    // 继续遍历子树
    if (fiber.child !== null) {
      fiber.child.return = fiber;
      fiber = fiber.child;
    } else {
      if (fiber === workInProgress) {
        return;
      }
      while (fiber.sibling === null) {
        if (fiber.return === null || fiber.return === workInProgress) {
          return;
        }
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      fiber = fiber.sibling;
    }
  }
}
```

#### useContext 的实现
```javascript
function useContext(context) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useContext(context);
}

function readContext(context, observedBits) {
  const currentFiber = getCurrentFiber();
  
  // 创建依赖关系
  const contextItem = {
    context: context,
    observedBits: observedBits,
    next: null,
  };
  
  if (lastContextDependency === null) {
    lastContextDependency = contextItem;
    currentFiber.dependencies = {
      lanes: NoLanes,
      firstContext: contextItem,
      responders: null,
    };
  } else {
    lastContextDependency = lastContextDependency.next = contextItem;
  }
  
  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
}
```

#### Context 性能优化
```javascript
// 问题：Context 值变化导致所有消费者重新渲染
const ThemeContext = createContext();

function App() {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  
  // 错误：每次渲染都创建新对象
  const contextValue = {
    theme,
    user,
    setTheme,
    setUser,
  };
  
  return (
    <ThemeContext.Provider value={contextValue}>
      <Header />
      <Main />
      <Footer />
    </ThemeContext.Provider>
  );
}

// 优化方案1：使用 useMemo 缓存 context 值
function App() {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  
  const contextValue = useMemo(() => ({
    theme,
    user,
    setTheme,
    setUser,
  }), [theme, user]);
  
  return (
    <ThemeContext.Provider value={contextValue}>
      <Header />
      <Main />
      <Footer />
    </ThemeContext.Provider>
  );
}

// 优化方案2：拆分 Context
const ThemeContext = createContext();
const UserContext = createContext();

function App() {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  
  const themeValue = useMemo(() => ({ theme, setTheme }), [theme]);
  const userValue = useMemo(() => ({ user, setUser }), [user]);
  
  return (
    <ThemeContext.Provider value={themeValue}>
      <UserContext.Provider value={userValue}>
        <Header />
        <Main />
        <Footer />
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}

// 优化方案3：使用 React.memo 包装消费者
const Header = React.memo(() => {
  const { theme } = useContext(ThemeContext);
  return <header className={theme}>Header</header>;
});

// 优化方案4：使用状态选择器模式
function createContextSelector() {
  const context = createContext();
  
  function useContextSelector(selector) {
    const value = useContext(context);
    const selectedValue = selector(value);
    
    const ref = useRef();
    
    if (!Object.is(ref.current, selectedValue)) {
      ref.current = selectedValue;
    }
    
    return ref.current;
  }
  
  return [context.Provider, useContextSelector];
}

const [ThemeProvider, useThemeSelector] = createContextSelector();

function Header() {
  // 只有 theme 变化时才重新渲染
  const theme = useThemeSelector(state => state.theme);
  return <header className={theme}>Header</header>;
}
```

### 5.3 第三方状态管理

#### Redux 核心原理
```javascript
// Redux 的核心实现
function createStore(reducer, preloadedState, enhancer) {
  let currentReducer = reducer;
  let currentState = preloadedState;
  let currentListeners = [];
  let nextListeners = currentListeners;
  let isDispatching = false;
  
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  
  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing.');
    }
    return currentState;
  }
  
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }
    
    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing.');
    }
    
    let isSubscribed = true;
    
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      
      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing.');
      }
      
      isSubscribed = false;
      
      ensureCanMutateNextListeners();
      const index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects.');
    }
    
    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property.');
    }
    
    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }
    
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    
    const listeners = (currentListeners = nextListeners);
    for (let i = 0; i < listeners.length; i++) {
      const listener = listeners[i];
      listener();
    }
    
    return action;
  }
  
  // 初始化状态
  dispatch({ type: '@@redux/INIT' });
  
  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
  };
}

// React-Redux 的 connect 实现原理
function connect(mapStateToProps, mapDispatchToProps) {
  return function wrapWithConnect(WrappedComponent) {
    function ConnectFunction(props) {
      const store = useContext(ReactReduxContext);
      const [, forceRender] = useReducer(s => s + 1, 0);
      
      const stateProps = mapStateToProps ? mapStateToProps(store.getState(), props) : {};
      const dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, props) : {};
      
      useEffect(() => {
        const unsubscribe = store.subscribe(() => {
          const newStateProps = mapStateToProps ? mapStateToProps(store.getState(), props) : {};
          if (!shallowEqual(stateProps, newStateProps)) {
            forceRender();
          }
        });
        
        return unsubscribe;
      }, [store, stateProps]);
      
      return <WrappedComponent {...props} {...stateProps} {...dispatchProps} />;
    }
    
    return ConnectFunction;
  };
}
```

#### Zustand 轻量级状态管理
```javascript
// Zustand 的核心实现
function create(createState) {
  let state;
  const listeners = new Set();
  
  const setState = (partial, replace) => {
    const nextState = typeof partial === 'function' ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach(listener => listener(state, previousState));
    }
  };
  
  const getState = () => state;
  
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  
  const destroy = () => listeners.clear();
  
  const api = { setState, getState, subscribe, destroy };
  state = createState(setState, getState, api);
  
  return api;
}

// 使用示例
const useStore = create((set, get) => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
  decrement: () => set(state => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 }),
}));

function Counter() {
  const { count, increment, decrement, reset } = useStore();
  
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

## 6. 事件系统 ⭐⭐⭐⭐

### 6.1 React 事件系统架构

#### 事件系统的设计目标
1. **跨浏览器兼容性**: 抹平不同浏览器的差异
2. **性能优化**: 通过事件委托减少内存占用
3. **统一的事件接口**: 提供一致的事件处理体验
4. **与 React 更新机制集成**: 事件处理与状态更新的协调

#### 事件系统的核心组件
```javascript
// 事件插件系统
const eventPluginOrder = [
  'ResponderEventPlugin',
  'SimpleEventPlugin',
  'EnterLeaveEventPlugin',
  'ChangeEventPlugin',
  'SelectEventPlugin',
  'BeforeInputEventPlugin',
];

// 事件名称映射
const topLevelEventsToReactNames = new Map([
  ['abort', 'onAbort'],
  ['animationend', 'onAnimationEnd'],
  ['animationiteration', 'onAnimationIteration'],
  ['animationstart', 'onAnimationStart'],
  ['blur', 'onBlur'],
  ['canplay', 'onCanPlay'],
  ['canplaythrough', 'onCanPlayThrough'],
  ['cancel', 'onCancel'],
  ['change', 'onChange'],
  ['click', 'onClick'],
  ['close', 'onClose'],
  ['contextmenu', 'onContextMenu'],
  // ... 更多事件映射
]);

// 事件优先级映射
function getEventPriority(domEventName) {
  switch (domEventName) {
    // 离散事件 - 高优先级
    case 'cancel':
    case 'click':
    case 'close':
    case 'contextmenu':
    case 'copy':
    case 'cut':
    case 'auxclick':
    case 'dblclick':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'invalid':
    case 'keydown':
    case 'keypress':
    case 'keyup':
    case 'mousedown':
    case 'mouseup':
    case 'paste':
    case 'pause':
    case 'play':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointerup':
    case 'ratechange':
    case 'reset':
    case 'resize':
    case 'seeked':
    case 'submit':
    case 'touchcancel':
    case 'touchend':
    case 'touchstart':
    case 'volumechange':
      return DiscreteEventPriority;
    
    // 连续事件 - 中等优先级
    case 'drag':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'scroll':
    case 'toggle':
    case 'touchmove':
    case 'wheel':
      return ContinuousEventPriority;
    
    // 默认事件 - 低优先级
    default:
      return DefaultEventPriority;
  }
}
```

### 6.2 SyntheticEvent（合成事件）

#### 合成事件的实现
```javascript
// 合成事件的基础接口
function SyntheticEvent(
  reactName,
  reactEventType,
  targetInst,
  nativeEvent,
  nativeEventTarget
) {
  this._reactName = reactName;
  this._targetInst = targetInst;
  this.type = reactEventType;
  this.nativeEvent = nativeEvent;
  this.target = nativeEventTarget;
  this.currentTarget = null;
  
  // 复制原生事件的属性
  for (const propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    const normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      this[propName] = nativeEvent[propName];
    }
  }
  
  const defaultPrevented = nativeEvent.defaultPrevented != null
    ? nativeEvent.defaultPrevented
    : nativeEvent.returnValue === false;
  
  if (defaultPrevented) {
    this.isDefaultPrevented = functionThatReturnsTrue;
  } else {
    this.isDefaultPrevented = functionThatReturnsFalse;
  }
  
  this.isPropagationStopped = functionThatReturnsFalse;
  return this;
}

// 合成事件的原型方法
Object.assign(SyntheticEvent.prototype, {
  preventDefault: function() {
    this.defaultPrevented = true;
    const event = this.nativeEvent;
    if (!event) {
      return;
    }
    
    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    
    this.isDefaultPrevented = functionThatReturnsTrue;
  },
  
  stopPropagation: function() {
    const event = this.nativeEvent;
    if (!event) {
      return;
    }
    
    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      event.cancelBubble = true;
    }
    
    this.isPropagationStopped = functionThatReturnsTrue;
  },
  
  persist: function() {
    // React 17+ 中，合成事件不再被池化
    // 这个方法保留是为了向后兼容
  },
  
  isPersistent: functionThatReturnsTrue,
});

// 特定类型的合成事件
function SyntheticMouseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.Interface = Object.assign({}, SyntheticEvent.Interface, {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: null,
  buttons: null,
  relatedTarget: function(event) {
    if (event.relatedTarget === undefined) {
      return event.fromElement === event.srcElement
        ? event.toElement
        : event.fromElement;
    }
    return event.relatedTarget;
  },
  movementX: function(event) {
    if ('movementX' in event) {
      return event.movementX;
    }
    return getEventMovementX(event);
  },
  movementY: function(event) {
    if ('movementY' in event) {
      return event.movementY;
    }
    return getEventMovementY(event);
  },
});
```

### 6.3 事件委托机制

#### 事件委托的实现
```javascript
// 在根容器上注册事件监听器
function listenToAllSupportedEvents(rootContainerElement) {
  if (!rootContainerElement[listeningMarker]) {
    rootContainerElement[listeningMarker] = true;
    
    // 遍历所有支持的事件
    allNativeEvents.forEach(domEventName => {
      // 某些事件不能委托，需要直接绑定
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(
          domEventName,
          false, // 不是捕获阶段
          rootContainerElement
        );
      }
      
      // 同时监听捕获阶段
      listenToNativeEvent(
        domEventName,
        true, // 捕获阶段
        rootContainerElement
      );
    });
  }
}

// 监听原生事件
function listenToNativeEvent(
  domEventName,
  isCapturePhaseListener,
  target
) {
  let eventSystemFlags = 0;
  if (isCapturePhaseListener) {
    eventSystemFlags |= IS_CAPTURE_PHASE;
  }
  
  addTrappedEventListener(
    target,
    domEventName,
    eventSystemFlags,
    isCapturePhaseListener
  );
}

// 添加事件监听器
function addTrappedEventListener(
  targetContainer,
  domEventName,
  eventSystemFlags,
  isCapturePhaseListener
) {
  const listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags
  );
  
  // 根据事件类型决定是否被动监听
  let isPassiveListener = undefined;
  if (passiveBrowserEventsSupported) {
    if (
      domEventName === 'touchstart' ||
      domEventName === 'touchmove' ||
      domEventName === 'wheel'
    ) {
      isPassiveListener = true;
    }
  }
  
  targetContainer = enableLegacyFBSupport
    ? (targetContainer || document)
    : targetContainer;
  
  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      addEventCaptureListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener
      );
    } else {
      addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    if (isPassiveListener !== undefined) {
      addEventBubbleListenerWithPassiveFlag(
        targetContainer,
        domEventName,
        listener,
        isPassiveListener
      );
    } else {
      addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}

// 创建带优先级的事件监听器
function createEventListenerWrapperWithPriority(
  targetContainer,
  domEventName,
  eventSystemFlags
) {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
}
```

### 6.4 事件处理流程

#### 事件分发机制
```javascript
// 离散事件分发
function dispatchDiscreteEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  const previousPriority = getCurrentUpdatePriority();
  const prevTransition = ReactCurrentBatchConfig.transition;
  ReactCurrentBatchConfig.transition = null;
  
  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority(previousPriority);
    ReactCurrentBatchConfig.transition = prevTransition;
    if (getCurrentUpdatePriority() === NoEventPriority) {
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}

// 连续事件分发
function dispatchContinuousEvent(
  domEventName,
  eventSystemFlags,
  container,
  nativeEvent
) {
  const previousPriority = getCurrentUpdatePriority();
  const prevTransition = ReactCurrentBatchConfig.transition;
  ReactCurrentBatchConfig.transition = null;
  
  try {
    setCurrentUpdatePriority(ContinuousEventPriority);
    dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
  } finally {
    setCurrentUpdatePriority(previousPriority);
    ReactCurrentBatchConfig.transition = prevTransition;
  }
}

// 通用事件分发
function dispatchEvent(
  domEventName,
  eventSystemFlags,
  targetContainer,
  nativeEvent
) {
  if (!_enabled) {
    return;
  }
  
  let blockedOn = findInstanceBlockingEvent(
    domEventName,
    eventSystemFlags,
    targetContainer,
    nativeEvent
  );
  
  if (blockedOn === null) {
    dispatchEventForPluginEventSystem(
      domEventName,
      eventSystemFlags,
      nativeEvent,
      return_targetInst,
      targetContainer
    );
    clearIfContinuousEvent(domEventName, nativeEvent);
    return;
  }
  
  if (
    queueIfContinuousEvent(
      blockedOn,
      domEventName,
      eventSystemFlags,
      targetContainer,
      nativeEvent
    )
  ) {
    nativeEvent.stopPropagation();
    return;
  }
  
  clearIfContinuousEvent(domEventName, nativeEvent);
  
  if (
    eventSystemFlags & IS_CAPTURE_PHASE &&
    isDiscreteEventThatRequiresHydration(domEventName)
  ) {
    while (blockedOn !== null) {
      const fiber = getInstanceFromNode(blockedOn);
      if (fiber !== null) {
        attemptSynchronousHydration(fiber);
      }
      
      const nextBlockedOn = findInstanceBlockingEvent(
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      );
      
      if (nextBlockedOn === null) {
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        );
      }
      
      if (nextBlockedOn === blockedOn) {
        break;
      }
      
      blockedOn = nextBlockedOn;
    }
    
    if (blockedOn !== null) {
      nativeEvent.stopPropagation();
    }
    
    return;
  }
  
  dispatchEventForPluginEventSystem(
    domEventName,
    eventSystemFlags,
    nativeEvent,
    return_targetInst,
    targetContainer
  );
}
```

#### 事件路径构建
```javascript
// 构建事件传播路径
function accumulateSinglePhaseListeners(
  targetFiber,
  reactName,
  nativeEventType,
  inCapturePhase,
  accumulateTargetOnly
) {
  const captureName = reactName !== null ? reactName + 'Capture' : null;
  const reactEventName = inCapturePhase ? captureName : reactName;
  let listeners = [];
  
  let instance = targetFiber;
  let lastHostComponent = null;
  
  // 向上遍历 Fiber 树
  while (instance !== null) {
    const {stateNode, tag} = instance;
    
    // 处理 HostComponent（DOM 元素）
    if (tag === HostComponent && stateNode !== null) {
      lastHostComponent = stateNode;
      
      if (reactEventName !== null) {
        const listener = getListener(instance, reactEventName);
        if (listener != null) {
          listeners.push(
            createDispatchListener(instance, listener, lastHostComponent)
          );
        }
      }
    }
    
    // 如果只收集目标元素的监听器，则停止
    if (accumulateTargetOnly) {
      break;
    }
    
    instance = instance.return;
  }
  
  return listeners;
}

// 创建分发监听器
function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance,
    listener,
    currentTarget,
  };
}

// 执行事件监听器
function executeDispatch(event, listener, currentTarget) {
  const type = event.type || 'unknown-event';
  event.currentTarget = currentTarget;
  
  try {
    listener(event);
  } catch (error) {
    reportGlobalError(error);
  }
  
  event.currentTarget = null;
}

// 处理事件传播
function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  const inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
  
  for (let i = 0; i < dispatchQueue.length; i++) {
    const {event, listeners} = dispatchQueue[i];
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
  }
}

function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  let previousInstance;
  
  if (inCapturePhase) {
    // 捕获阶段：从外到内
    for (let i = dispatchListeners.length - 1; i >= 0; i--) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    // 冒泡阶段：从内到外
    for (let i = 0; i < dispatchListeners.length; i++) {
      const {instance, currentTarget, listener} = dispatchListeners[i];
      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }
      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  }
}
```

### 6.5 特殊事件处理

#### onChange 事件的特殊处理
```javascript
// onChange 事件插件
function extractEvents(
  dispatchQueue,
  domEventName,
  targetInst,
  nativeEvent,
  nativeEventTarget,
  eventSystemFlags,
  targetContainer
) {
  const targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  
  let getTargetInstFunc, handleEventFunc;
  
  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }
  
  if (getTargetInstFunc) {
    const inst = getTargetInstFunc(domEventName, targetInst);
    if (inst) {
      const event = createAndAccumulateChangeEvent(
        dispatchQueue,
        inst,
        nativeEvent,
        nativeEventTarget
      );
      return event;
    }
  }
  
  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  }
  
  // 当 blur 一个 input 元素时，如果值发生了变化，触发 onChange
  if (domEventName === 'focusout') {
    handleControlledInputBlur(targetNode);
  }
}

// 判断是否应该使用 change 事件
function shouldUseChangeEvent(elem) {
  const nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return (
    nodeName === 'select' ||
    (nodeName === 'input' && elem.type === 'file')
  );
}

// 判断是否应该使用 click 事件
function shouldUseClickEvent(elem) {
  const nodeName = elem.nodeName;
  return (
    nodeName &&
    nodeName.toLowerCase() === 'input' &&
    (elem.type === 'checkbox' || elem.type === 'radio')
  );
}
```

### 6.6 React 17 的事件系统变化

#### 事件委托的变化
```javascript
// React 16 及之前：事件委托到 document
document.addEventListener('click', dispatchEvent);

// React 17+：事件委托到根容器
rootContainer.addEventListener('click', dispatchEvent);
```

#### 事件池的移除
```javascript
// React 16 及之前：需要调用 persist() 保持事件对象
function handleClick(e) {
  e.persist(); // 保持事件对象
  setTimeout(() => {
    console.log(e.target); // 可以访问
  }, 1000);
}

// React 17+：事件对象不再被池化
function handleClick(e) {
  setTimeout(() => {
    console.log(e.target); // 直接可以访问
  }, 1000);
}
```

### 6.7 事件系统性能优化

#### 事件委托的优势
1. **内存优化**: 减少事件监听器数量
2. **动态元素**: 新增元素自动具有事件处理能力
3. **统一管理**: 便于事件的统一处理和优化

#### 性能最佳实践
```javascript
// 避免在渲染中创建新的事件处理函数
// 错误示例
function BadComponent() {
  return (
    <button onClick={() => console.log('clicked')}>
      Click me
    </button>
  );
}

// 正确示例
function GoodComponent() {
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);
  
  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}

// 使用事件委托处理列表项
function ListComponent({ items }) {
  const handleItemClick = useCallback((e) => {
    const itemId = e.target.dataset.itemId;
    console.log('Clicked item:', itemId);
  }, []);
  
  return (
    <ul onClick={handleItemClick}>
      {items.map(item => (
        <li key={item.id} data-item-id={item.id}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

## 7. 性能优化 ⭐⭐⭐⭐⭐

### 7.1 组件级别优化

#### React.memo 深度解析
```javascript
// React.memo 的实现原理
function memo(type, compare) {
  const elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type,
    compare: compare === undefined ? null : compare,
  };
  
  return elementType;
}

// 在 Fiber 中的处理
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  updateLanes,
  renderLanes
) {
  if (current === null) {
    // 首次渲染
    const type = Component.type;
    if (isSimpleFunctionComponent(type) && Component.compare === null) {
      // 简单函数组件优化
      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = type;
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        type,
        nextProps,
        updateLanes,
        renderLanes
      );
    }
  }
  
  const currentChild = current !== null ? current.child : null;
  
  if (!includesSomeLane(renderLanes, updateLanes)) {
    // 当前更新不包含此组件的更新优先级
    const prevProps = currentChild.memoizedProps;
    let compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;
    
    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      // props 相同且 ref 相同，可以跳过更新
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  }
  
  // 需要更新，继续渲染
  const newChild = createFiberFromTypeAndProps(
    Component.type,
    null,
    nextProps,
    workInProgress,
    workInProgress.mode,
    renderLanes
  );
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  
  return newChild;
}

// 使用示例和最佳实践
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  console.log('ExpensiveComponent 渲染');
  
  const processedData = useMemo(() => {
    return data.map(item => ({
      ...item,
      processed: true,
      timestamp: Date.now()
    }));
  }, [data]);
  
  return (
    <div>
      {processedData.map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
      <button onClick={onUpdate}>Update</button>
    </div>
  );
});

// 自定义比较函数
const CustomMemoComponent = React.memo(({ user, settings }) => {
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{settings.theme}</p>
    </div>
  );
}, (prevProps, nextProps) => {
  // 自定义比较逻辑
  return (
    prevProps.user.id === nextProps.user.id &&
    prevProps.user.name === nextProps.user.name &&
    prevProps.settings.theme === nextProps.settings.theme
  );
});
```

#### PureComponent 和 shouldComponentUpdate
```javascript
// PureComponent 的实现原理
class PureComponent extends Component {
  constructor(props) {
    super(props);
    this.isPureReactComponent = true;
  }
}

// React 内部对 PureComponent 的处理
function checkShouldComponentUpdate(
  workInProgress,
  ctor,
  oldProps,
  newProps,
  oldState,
  newState,
  nextContext
) {
  const instance = workInProgress.stateNode;
  
  if (typeof instance.shouldComponentUpdate === 'function') {
    // 自定义 shouldComponentUpdate
    const shouldUpdate = instance.shouldComponentUpdate(
      newProps,
      newState,
      nextContext
    );
    return shouldUpdate;
  }
  
  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    // PureComponent 的浅比较
    return (
      !shallowEqual(oldProps, newProps) ||
      !shallowEqual(oldState, newState)
    );
  }
  
  return true;
}

// 浅比较的实现
function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  
  if (
    typeof objA !== 'object' ||
    objA === null ||
    typeof objB !== 'object' ||
    objB === null
  ) {
    return false;
  }
  
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  
  if (keysA.length !== keysB.length) {
    return false;
  }
  
  for (let i = 0; i < keysA.length; i++) {
    if (
      !hasOwnProperty.call(objB, keysA[i]) ||
      !Object.is(objA[keysA[i]], objB[keysA[i]])
    ) {
      return false;
    }
  }
  
  return true;
}

// 使用示例
class OptimizedComponent extends PureComponent {
  render() {
    const { data, onUpdate } = this.props;
    console.log('OptimizedComponent 渲染');
    
    return (
      <div>
        <h1>{data.title}</h1>
        <p>{data.content}</p>
        <button onClick={onUpdate}>Update</button>
      </div>
    );
  }
}

// 手动控制更新
class ManualOptimizedComponent extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    // 只有特定属性变化时才更新
    return (
      this.props.importantData !== nextProps.importantData ||
      this.state.criticalState !== nextState.criticalState
    );
  }
  
  render() {
    return (
      <div>
        <h1>{this.props.importantData}</h1>
        <p>{this.state.criticalState}</p>
      </div>
    );
  }
}
```

### 7.2 Hooks 优化深度解析

#### useMemo 和 useCallback 实现原理
```javascript
// useMemo 的实现原理
function useMemo(create, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 依赖没有变化，返回缓存值
        return prevState[0];
      }
    }
  }
  
  // 依赖变化或首次执行，重新计算
  const nextValue = create();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

// useCallback 的实现原理
function useCallback(callback, deps) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        // 依赖没有变化，返回缓存的回调
        return prevState[0];
      }
    }
  }
  
  // 依赖变化或首次执行，缓存新的回调
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

// 依赖比较的实现
function areHookInputsEqual(nextDeps, prevDeps) {
  if (prevDeps === null) {
    return false;
  }
  
  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (Object.is(nextDeps[i], prevDeps[i])) {
      continue;
    }
    return false;
  }
  return true;
}

// 实际使用示例
function SearchComponent({ items, filters }) {
  const [query, setQuery] = useState('');
  
  // 缓存过滤后的结果
  const filteredItems = useMemo(() => {
    console.log('重新计算过滤结果');
    return items
      .filter(item => item.name.toLowerCase().includes(query.toLowerCase()))
      .filter(item => filters.every(filter => filter(item)))
      .sort((a, b) => a.name.localeCompare(b.name));
  }, [items, query, filters]);
  
  // 缓存事件处理函数
  const handleSearch = useCallback((e) => {
    setQuery(e.target.value);
  }, []);
  
  // 缓存复杂计算
  const statistics = useMemo(() => {
    console.log('重新计算统计信息');
    return {
      total: filteredItems.length,
      categories: filteredItems.reduce((acc, item) => {
        acc[item.category] = (acc[item.category] || 0) + 1;
        return acc;
      }, {}),
      averagePrice: filteredItems.reduce((sum, item) => sum + item.price, 0) / filteredItems.length
    };
  }, [filteredItems]);
  
  return (
    <div>
      <input 
        type="text" 
        value={query} 
        onChange={handleSearch}
        placeholder="搜索..."
      />
      <div>找到 {statistics.total} 个结果</div>
      <div>平均价格: ${statistics.averagePrice.toFixed(2)}</div>
      {filteredItems.map(item => (
        <ItemComponent key={item.id} item={item} />
      ))}
    </div>
  );
}
```

### 7.3 代码分割和懒加载

#### React.lazy 实现原理
```javascript
// React.lazy 的实现
function lazy(ctor) {
  const payload = {
    _status: -1, // Pending
    _result: ctor,
  };
  
  const lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer,
  };
  
  return lazyType;
}

function lazyInitializer(payload) {
  if (payload._status === -1) { // Pending
    const ctor = payload._result;
    const thenable = ctor();
    
    // 处理 Promise
    const pending = payload;
    pending._status = 0; // Pending
    pending._result = thenable;
    
    thenable.then(
      moduleObject => {
        if (pending._status === 0) { // Pending
          const defaultExport = moduleObject.default;
          pending._status = 1; // Resolved
          pending._result = defaultExport;
        }
      },
      error => {
        if (pending._status === 0) { // Pending
          pending._status = 2; // Rejected
          pending._result = error;
        }
      }
    );
  }
  
  if (payload._status === 1) { // Resolved
    return payload._result;
  } else {
    throw payload._result;
  }
}

// 实际使用示例
const LazyComponent = React.lazy(() => import('./HeavyComponent'));
const LazyRoute = React.lazy(() => import('./pages/Dashboard'));

function App() {
  const [showHeavy, setShowHeavy] = useState(false);
  
  return (
    <div>
      <h1>主应用</h1>
      
      {/* 组件级别的懒加载 */}
      <button onClick={() => setShowHeavy(!showHeavy)}>
        {showHeavy ? '隐藏' : '显示'}重型组件
      </button>
      
      {showHeavy && (
        <Suspense fallback={<div>加载重型组件中...</div>}>
          <LazyComponent />
        </Suspense>
      )}
      
      {/* 路由级别的懒加载 */}
      <Router>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route 
            path="/dashboard" 
            element={
              <Suspense fallback={<div>加载仪表板中...</div>}>
                <LazyRoute />
              </Suspense>
            } 
          />
        </Routes>
      </Router>
    </div>
  );
}
```

### 7.4 列表和虚拟滚动优化

#### 虚拟滚动实现
```javascript
// 虚拟滚动组件实现
function VirtualList({ 
  items, 
  itemHeight, 
  containerHeight, 
  renderItem,
  overscan = 5 
}) {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef();
  
  // 计算可见范围
  const visibleRange = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight),
      items.length - 1
    );
    
    return {
      start: Math.max(0, startIndex - overscan),
      end: Math.min(items.length - 1, endIndex + overscan)
    };
  }, [scrollTop, itemHeight, containerHeight, items.length, overscan]);
  
  // 可见项目
  const visibleItems = useMemo(() => {
    const result = [];
    for (let i = visibleRange.start; i <= visibleRange.end; i++) {
      result.push({
        index: i,
        item: items[i],
        style: {
          position: 'absolute',
          top: i * itemHeight,
          height: itemHeight,
          width: '100%'
        }
      });
    }
    return result;
  }, [visibleRange, items, itemHeight]);
  
  // 滚动处理
  const handleScroll = useCallback((e) => {
    setScrollTop(e.target.scrollTop);
  }, []);
  
  // 总高度
  const totalHeight = items.length * itemHeight;
  
  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        {visibleItems.map(({ index, item, style }) => (
          <div key={index} style={style}>
            {renderItem(item, index)}
          </div>
        ))}
      </div>
    </div>
  );
}

// 使用示例
function App() {
  const [items] = useState(() => 
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
      description: `Description for item ${i}`,
      value: Math.random() * 1000
    }))
  );
  
  const renderItem = useCallback((item, index) => (
    <div style={{ padding: '10px', borderBottom: '1px solid #eee' }}>
      <h3>{item.name}</h3>
      <p>{item.description}</p>
      <span>Value: {item.value.toFixed(2)}</span>
    </div>
  ), []);
  
  return (
    <div>
      <h1>虚拟滚动示例</h1>
      <VirtualList
        items={items}
        itemHeight={80}
        containerHeight={400}
        renderItem={renderItem}
      />
    </div>
  );
}
```

## 8. JSX 原理 ⭐⭐⭐

### 8.1 JSX 编译过程深度解析

#### Babel 编译 JSX
```javascript
// 原始 JSX 代码
function App() {
  const name = 'React';
  const isLoggedIn = true;
  
  return (
    <div className="app" id="main">
      <h1 style={{ color: 'blue' }}>Hello {name}!</h1>
      {isLoggedIn && <p>Welcome back!</p>}
      <button onClick={() => console.log('clicked')}>Click me</button>
      <ul>
        {[1, 2, 3].map(num => (
          <li key={num}>Item {num}</li>
        ))}
      </ul>
    </div>
  );
}

// React 17 之前的编译结果
function App() {
  const name = 'React';
  const isLoggedIn = true;
  
  return React.createElement(
    'div',
    {
      className: 'app',
      id: 'main'
    },
    React.createElement(
      'h1',
      {
        style: { color: 'blue' }
      },
      'Hello ',
      name,
      '!'
    ),
    isLoggedIn && React.createElement('p', null, 'Welcome back!'),
    React.createElement(
      'button',
      {
        onClick: () => console.log('clicked')
      },
      'Click me'
    ),
    React.createElement(
      'ul',
      null,
      [1, 2, 3].map(num =>
        React.createElement(
          'li',
          {
            key: num
          },
          'Item ',
          num
        )
      )
    )
  );
}

// React 17+ 的编译结果（新的 JSX Transform）
import { jsx as _jsx, jsxs as _jsxs } from 'react/jsx-runtime';

function App() {
  const name = 'React';
  const isLoggedIn = true;
  
  return _jsxs('div', {
    className: 'app',
    id: 'main',
    children: [
      _jsxs('h1', {
        style: { color: 'blue' },
        children: ['Hello ', name, '!']
      }),
      isLoggedIn && _jsx('p', {
        children: 'Welcome back!'
      }),
      _jsx('button', {
        onClick: () => console.log('clicked'),
        children: 'Click me'
      }),
      _jsx('ul', {
        children: [1, 2, 3].map(num =>
          _jsx('li', {
            children: ['Item ', num]
          }, num)
        )
      })
    ]
  });
}
```

#### JSX 编译配置
```javascript
// Babel 配置 (.babelrc)
{
  "presets": [
    [
      "@babel/preset-react",
      {
        "runtime": "automatic", // 使用新的 JSX Transform
        "development": true,    // 开发模式，添加调试信息
        "importSource": "react" // 指定 JSX 运行时来源
      }
    ]
  ]
}

// TypeScript 配置 (tsconfig.json)
{
  "compilerOptions": {
    "jsx": "react-jsx",        // 使用新的 JSX Transform
    "jsxImportSource": "react" // 指定 JSX 运行时来源
  }
}

// Webpack 配置
module.exports = {
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-react', {
                runtime: 'automatic'
              }]
            ]
          }
        }
      }
    ]
  }
};
```

### 8.2 createElement 实现原理

#### React.createElement 源码分析
```javascript
// React.createElement 的实现
function createElement(type, config, children) {
  let propName;
  const props = {};
  let key = null;
  let ref = null;
  let self = null;
  let source = null;
  
  if (config != null) {
    // 提取特殊属性
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }
    
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    
    // 复制其他属性到 props
    for (propName in config) {
      if (
        hasOwnProperty.call(config, propName) &&
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }
  
  // 处理 children
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }
  
  // 处理默认 props
  if (type && type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props
  );
}

// ReactElement 工厂函数
function ReactElement(type, key, ref, self, source, owner, props) {
  const element = {
    // 标识这是一个 React Element
    $$typeof: REACT_ELEMENT_TYPE,
    
    // 元素的内置属性
    type: type,
    key: key,
    ref: ref,
    props: props,
    
    // 记录创建此元素的组件
    _owner: owner,
  };
  
  if (__DEV__) {
    // 开发模式下的额外信息
    element._store = {};
    
    // 防止意外修改
    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false,
    });
    
    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self,
    });
    
    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source,
    });
    
    // 冻结元素和 props
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }
  
  return element;
}

// 新的 JSX Runtime 实现
function jsx(type, config, maybeKey) {
  let propName;
  const props = {};
  let key = null;
  let ref = null;
  
  // 处理 key
  if (maybeKey !== undefined) {
    key = '' + maybeKey;
  }
  
  if (hasValidKey(config)) {
    key = '' + config.key;
  }
  
  if (hasValidRef(config)) {
    ref = config.ref;
  }
  
  // 复制属性到 props
  for (propName in config) {
    if (
      hasOwnProperty.call(config, propName) &&
      !RESERVED_PROPS.hasOwnProperty(propName)
    ) {
      props[propName] = config[propName];
    }
  }
  
  // 处理默认 props
  if (type && type.defaultProps) {
    const defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  
  return ReactElement(
    type,
    key,
    ref,
    undefined,
    undefined,
    ReactCurrentOwner.current,
    props
  );
}

// jsxs 用于多个子元素
const jsxs = jsx;
```

### 8.3 JSX 的特殊处理

#### Fragment 的处理
```javascript
// JSX Fragment 语法
function App() {
  return (
    <>
      <h1>Title</h1>
      <p>Content</p>
    </>
  );
}

// 编译后
function App() {
  return React.createElement(
    React.Fragment,
    null,
    React.createElement('h1', null, 'Title'),
    React.createElement('p', null, 'Content')
  );
}

// 或者使用新的 JSX Transform
import { Fragment as _Fragment, jsx as _jsx, jsxs as _jsxs } from 'react/jsx-runtime';

function App() {
  return _jsxs(_Fragment, {
    children: [
      _jsx('h1', { children: 'Title' }),
      _jsx('p', { children: 'Content' })
    ]
  });
}

// React.Fragment 的实现
const REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');

const Fragment = REACT_FRAGMENT_TYPE;
```

#### 条件渲染的处理
```javascript
// 条件渲染 JSX
function ConditionalComponent({ isVisible, items }) {
  return (
    <div>
      {isVisible && <p>Visible content</p>}
      {items.length > 0 ? (
        <ul>
          {items.map(item => <li key={item.id}>{item.name}</li>)}
        </ul>
      ) : (
        <p>No items</p>
      )}
    </div>
  );
}

// 编译后的处理
function ConditionalComponent({ isVisible, items }) {
  return React.createElement(
    'div',
    null,
    isVisible && React.createElement('p', null, 'Visible content'),
    items.length > 0
      ? React.createElement(
          'ul',
          null,
          items.map(item =>
            React.createElement('li', { key: item.id }, item.name)
          )
        )
      : React.createElement('p', null, 'No items')
  );
}

// React 如何处理 false、null、undefined
function processChildren(children) {
  const result = [];
  
  React.Children.forEach(children, child => {
    if (child != null && child !== false && child !== true) {
      if (typeof child === 'string' || typeof child === 'number') {
        result.push(child);
      } else if (React.isValidElement(child)) {
        result.push(child);
      } else if (Array.isArray(child)) {
        result.push(...processChildren(child));
      }
    }
  });
  
  return result;
}
```

### 8.4 JSX 性能优化

#### 避免内联对象和函数
```javascript
// 错误示例：每次渲染都创建新对象
function BadComponent({ items }) {
  return (
    <div>
      {items.map(item => (
        <ItemComponent
          key={item.id}
          item={item}
          style={{ marginBottom: '10px' }} // 每次都创建新对象
          onClick={() => handleClick(item.id)} // 每次都创建新函数
        />
      ))}
    </div>
  );
}

// 正确示例：缓存对象和函数
function GoodComponent({ items }) {
  const itemStyle = useMemo(() => ({ marginBottom: '10px' }), []);
  
  const handleItemClick = useCallback((itemId) => {
    handleClick(itemId);
  }, []);
  
  return (
    <div>
      {items.map(item => (
        <ItemComponent
          key={item.id}
          item={item}
          style={itemStyle}
          onClick={() => handleItemClick(item.id)}
        />
      ))}
    </div>
  );
}

// 更好的方案：将事件处理移到子组件
const ItemComponent = React.memo(({ item, style, onItemClick }) => {
  const handleClick = useCallback(() => {
    onItemClick(item.id);
  }, [item.id, onItemClick]);
  
  return (
    <div style={style} onClick={handleClick}>
      {item.name}
    </div>
  );
});

function OptimalComponent({ items }) {
  const itemStyle = useMemo(() => ({ marginBottom: '10px' }), []);
  
  const handleItemClick = useCallback((itemId) => {
    handleClick(itemId);
  }, []);
  
  return (
    <div>
      {items.map(item => (
        <ItemComponent
          key={item.id}
          item={item}
          style={itemStyle}
          onItemClick={handleItemClick}
        />
      ))}
    </div>
  );
}
```

#### JSX 编译时优化
```javascript
// 编译时常量提升
function Component() {
  // 这个元素会被提升到组件外部
  const staticElement = <div className="static">Static content</div>;
  
  return (
    <div>
      {staticElement}
      <p>Dynamic content</p>
    </div>
  );
}

// 编译后（简化）
const _hoisted_1 = React.createElement('div', {
  className: 'static'
}, 'Static content');

function Component() {
  return React.createElement(
    'div',
    null,
    _hoisted_1,
    React.createElement('p', null, 'Dynamic content')
  );
}

// 内联元素优化
function OptimizedComponent({ title }) {
  return (
    <div>
      <h1>{title}</h1>
      {/* 这些静态元素可以被优化 */}
      <footer>
        <p>© 2023 Company</p>
        <a href="/privacy">Privacy Policy</a>
      </footer>
    </div>
  );
}
```

## 9. 协调算法 (Reconciliation) ⭐⭐⭐⭐

### 9.1 协调算法概述

#### 什么是协调算法
协调算法是React用来比较新旧Virtual DOM树，找出最小变更集合的算法。React通过这个算法决定如何高效地更新真实DOM。

```javascript
// 协调过程的核心流程
function reconcileChildren(current, workInProgress, nextChildren) {
  if (current === null) {
    // 首次渲染，直接挂载
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes
    );
  } else {
    // 更新阶段，进行diff
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes
    );
  }
}

// 协调器的核心实现
function reconcileChildFibers(
  returnFiber,
  currentFirstChild,
  newChild,
  lanes
) {
  // 处理Fragment
  const isUnkeyedTopLevelFragment =
    typeof newChild === 'object' &&
    newChild !== null &&
    newChild.type === REACT_FRAGMENT_TYPE &&
    newChild.key === null;
  
  if (isUnkeyedTopLevelFragment) {
    newChild = newChild.props.children;
  }
  
  // 处理对象类型的子元素
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        return placeSingleChild(
          reconcileSingleElement(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          )
        );
      case REACT_PORTAL_TYPE:
        return placeSingleChild(
          reconcileSinglePortal(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          )
        );
    }
    
    // 处理数组类型的子元素
    if (isArray(newChild)) {
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
    }
    
    // 处理可迭代对象
    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        lanes
      );
    }
  }
  
  // 处理文本节点
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    return placeSingleChild(
      reconcileSingleTextNode(
        returnFiber,
        currentFirstChild,
        '' + newChild,
        lanes
      )
    );
  }
  
  // 删除剩余的子节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

### 9.2 Stack Reconciler vs Fiber Reconciler

#### Stack Reconciler (React 15)
```javascript
// Stack Reconciler 的递归实现
function reconcileChildren(element, children) {
  // 递归处理，无法中断
  if (Array.isArray(children)) {
    children.forEach((child, index) => {
      reconcileChild(element, child, index);
    });
  } else if (children) {
    reconcileChild(element, children, 0);
  }
}

function reconcileChild(parent, child, index) {
  if (typeof child === 'string' || typeof child === 'number') {
    // 处理文本节点
    updateTextNode(parent, child, index);
  } else if (child && child.type) {
    // 处理元素节点
    updateElement(parent, child, index);
    
    // 递归处理子节点（无法中断）
    if (child.props && child.props.children) {
      reconcileChildren(child, child.props.children);
    }
  }
}

// Stack Reconciler 的问题
function demonstrateStackProblem() {
  // 假设有一个深层嵌套的组件树
  const deepTree = createDeepTree(1000); // 1000层深度
  
  // Stack Reconciler 会一次性处理完所有节点
  // 这可能导致主线程被阻塞很长时间
  reconcileChildren(container, deepTree); // 阻塞主线程
  
  // 在这期间，用户交互、动画等都会被阻塞
  // 导致页面卡顿
}
```

#### Fiber Reconciler (React 16+)
```javascript
// Fiber Reconciler 的可中断实现
function workLoopConcurrent() {
  // 只要还有工作要做，并且没有更高优先级的任务
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  const current = unitOfWork.alternate;
  
  // 开始处理当前节点
  let next = beginWork(current, unitOfWork, renderLanes);
  
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  
  if (next === null) {
    // 如果没有子节点，完成当前节点
    completeUnitOfWork(unitOfWork);
  } else {
    // 继续处理子节点
    workInProgress = next;
  }
}

// 时间切片的实现
function shouldYield() {
  const currentTime = getCurrentTime();
  
  // 如果当前时间片用完了，就让出控制权
  if (currentTime >= deadline) {
    return true;
  }
  
  // 检查是否有更高优先级的任务
  if (hasHigherPriorityWork()) {
    return true;
  }
  
  return false;
}

// Scheduler 调度器
function scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const timeout = timeoutForPriorityLevel(priorityLevel);
  const expirationTime = currentTime + timeout;
  
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime: currentTime,
    expirationTime,
    sortIndex: expirationTime,
  };
  
  // 将任务加入调度队列
  push(taskQueue, newTask);
  
  // 请求调度
  requestHostCallback(flushWork);
  
  return newTask;
}
```

### 9.3 Diff算法的三个策略

#### 策略一：Tree Diff - 分层比较
```javascript
// React只会对同层级的节点进行比较
function diffTree(oldTree, newTree) {
  // 只比较同一层级的节点
  if (oldTree.type !== newTree.type) {
    // 类型不同，直接替换整个子树
    return {
      type: 'REPLACE',
      node: newTree
    };
  }
  
  // 类型相同，继续比较子节点
  const patches = [];
  const oldChildren = oldTree.children || [];
  const newChildren = newTree.children || [];
  
  // 递归比较子节点
  for (let i = 0; i < Math.max(oldChildren.length, newChildren.length); i++) {
    const childPatch = diffTree(oldChildren[i], newChildren[i]);
    if (childPatch) {
      patches.push({
        index: i,
        patch: childPatch
      });
    }
  }
  
  return patches.length > 0 ? patches : null;
}

// 跨层级移动的处理
function handleCrossLevelMove() {
  // React不会尝试复用跨层级移动的节点
  // 而是删除旧节点，创建新节点
  
  // 旧结构
  // <div>
  //   <p>text</p>
  // </div>
  
  // 新结构  
  // <div>
  //   <div>
  //     <p>text</p>
  //   </div>
  // </div>
  
  // React会删除旧的<p>，创建新的<p>
  // 而不是移动<p>到新位置
}
```

#### 策略二：Component Diff - 组件比较
```javascript
// 组件类型相同的处理
function reconcileSingleElement(
  returnFiber,
  currentFirstChild,
  element,
  lanes
) {
  const key = element.key;
  let child = currentFirstChild;
  
  while (child !== null) {
    // 比较key
    if (child.key === key) {
      // 比较元素类型
      if (child.elementType === element.type) {
        // key和type都相同，可以复用
        deleteRemainingChildren(returnFiber, child.sibling);
        
        const existing = useFiber(child, element.props);
        existing.ref = coerceRef(returnFiber, child, element);
        existing.return = returnFiber;
        
        return existing;
      } else {
        // key相同但type不同，删除所有子节点
        deleteRemainingChildren(returnFiber, child);
        break;
      }
    } else {
      // key不同，删除当前节点
      deleteChild(returnFiber, child);
    }
    
    child = child.sibling;
  }
  
  // 创建新的Fiber节点
  const created = createFiberFromElement(element, returnFiber.mode, lanes);
  created.ref = coerceRef(returnFiber, currentFirstChild, element);
  created.return = returnFiber;
  
  return created;
}

// 组件类型不同的处理
function handleDifferentComponentTypes(oldComponent, newComponent) {
  // 1. 卸载旧组件
  unmountComponent(oldComponent);
  
  // 2. 挂载新组件
  mountComponent(newComponent);
  
  // 示例：
  // 从 <div> 变为 <span>
  // React会完全销毁<div>及其子树，然后创建新的<span>
}

// 组件类型相同的处理
function handleSameComponentType(oldComponent, newComponent) {
  // 1. 保持组件实例不变
  // 2. 更新props
  // 3. 调用组件的更新方法
  
  if (oldComponent.type === newComponent.type) {
    // 函数组件
    if (typeof oldComponent.type === 'function') {
      // 直接调用函数，传入新props
      return oldComponent.type(newComponent.props);
    }
    
    // 类组件
    if (oldComponent.type.prototype && oldComponent.type.prototype.isReactComponent) {
      // 调用componentWillReceiveProps, shouldComponentUpdate等
      const instance = oldComponent.stateNode;
      instance.props = newComponent.props;
      
      if (instance.shouldComponentUpdate && 
          !instance.shouldComponentUpdate(newComponent.props, instance.state)) {
        return oldComponent; // 不需要更新
      }
      
      return instance.render();
    }
  }
}
```

#### 策略三：Element Diff - 元素比较
```javascript
// 列表元素的Diff算法
function reconcileChildrenArray(
  returnFiber,
  currentFirstChild,
  newChildren,
  lanes
) {
  let resultingFirstChild = null;
  let previousNewFiber = null;
  
  let oldFiber = currentFirstChild;
  let lastPlacedIndex = 0;
  let newIdx = 0;
  let nextOldFiber = null;
  
  // 第一轮遍历：处理更新的节点
  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
    if (oldFiber.index > newIdx) {
      nextOldFiber = oldFiber;
      oldFiber = null;
    } else {
      nextOldFiber = oldFiber.sibling;
    }
    
    const newFiber = updateSlot(
      returnFiber,
      oldFiber,
      newChildren[newIdx],
      lanes
    );
    
    if (newFiber === null) {
      // key不匹配，跳出第一轮遍历
      if (oldFiber === null) {
        oldFiber = nextOldFiber;
      }
      break;
    }
    
    if (shouldTrackSideEffects) {
      if (oldFiber && newFiber.alternate === null) {
        // 新节点没有复用旧节点，删除旧节点
        deleteChild(returnFiber, oldFiber);
      }
    }
    
    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
    
    if (previousNewFiber === null) {
      resultingFirstChild = newFiber;
    } else {
      previousNewFiber.sibling = newFiber;
    }
    
    previousNewFiber = newFiber;
    oldFiber = nextOldFiber;
  }
  
  // 新节点遍历完，删除剩余的旧节点
  if (newIdx === newChildren.length) {
    deleteRemainingChildren(returnFiber, oldFiber);
    return resultingFirstChild;
  }
  
  // 旧节点遍历完，创建剩余的新节点
  if (oldFiber === null) {
    for (; newIdx < newChildren.length; newIdx++) {
      const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
      if (newFiber === null) {
        continue;
      }
      
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      
      previousNewFiber = newFiber;
    }
    
    return resultingFirstChild;
  }
  
  // 第二轮遍历：处理移动、新增、删除
  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);
  
  for (; newIdx < newChildren.length; newIdx++) {
    const newFiber = updateFromMap(
      existingChildren,
      returnFiber,
      newIdx,
      newChildren[newIdx],
      lanes
    );
    
    if (newFiber !== null) {
      if (shouldTrackSideEffects) {
        if (newFiber.alternate !== null) {
          // 复用了旧节点，从map中删除
          existingChildren.delete(
            newFiber.key === null ? newIdx : newFiber.key
          );
        }
      }
      
      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
      
      if (previousNewFiber === null) {
        resultingFirstChild = newFiber;
      } else {
        previousNewFiber.sibling = newFiber;
      }
      
      previousNewFiber = newFiber;
    }
  }
  
  if (shouldTrackSideEffects) {
    // 删除map中剩余的旧节点
    existingChildren.forEach(child => deleteChild(returnFiber, child));
  }
  
  return resultingFirstChild;
}

// 节点移动的判断逻辑
function placeChild(newFiber, lastPlacedIndex, newIndex) {
  newFiber.index = newIndex;
  
  if (!shouldTrackSideEffects) {
    return lastPlacedIndex;
  }
  
  const current = newFiber.alternate;
  if (current !== null) {
    const oldIndex = current.index;
    if (oldIndex < lastPlacedIndex) {
      // 需要移动
      newFiber.flags |= Placement;
      return lastPlacedIndex;
    } else {
      // 不需要移动
      return oldIndex;
    }
  } else {
    // 新节点
    newFiber.flags |= Placement;
    return lastPlacedIndex;
  }
}
```

### 9.4 Key的作用机制

#### Key的重要性
```javascript
// 没有key的情况
function WithoutKey() {
  const [items, setItems] = useState(['A', 'B', 'C']);
  
  // 在开头插入新元素
  const insertAtBeginning = () => {
    setItems(['X', ...items]);
  };
  
  return (
    <div>
      {items.map((item, index) => (
        <input key={index} defaultValue={item} />
      ))}
    </div>
  );
}

// React的处理过程（使用index作为key）：
// 旧: [<input key={0} value="A" />, <input key={1} value="B" />, <input key={2} value="C" />]
// 新: [<input key={0} value="X" />, <input key={1} value="A" />, <input key={2} value="B" />, <input key={3} value="C" />]
// 结果：所有input的value都会被更新，性能很差

// 使用稳定key的情况
function WithStableKey() {
  const [items, setItems] = useState([
    { id: 'a', value: 'A' },
    { id: 'b', value: 'B' },
    { id: 'c', value: 'C' }
  ]);
  
  const insertAtBeginning = () => {
    setItems([{ id: 'x', value: 'X' }, ...items]);
  };
  
  return (
    <div>
      {items.map(item => (
        <input key={item.id} defaultValue={item.value} />
      ))}
    </div>
  );
}

// React的处理过程（使用稳定key）：
// 旧: [<input key="a" value="A" />, <input key="b" value="B" />, <input key="c" value="C" />]
// 新: [<input key="x" value="X" />, <input key="a" value="A" />, <input key="b" value="B" />, <input key="c" value="C" />]
// 结果：只创建一个新的input，其他input被复用，性能很好
```

#### Key的匹配算法
```javascript
// updateSlot函数：根据key匹配节点
function updateSlot(returnFiber, oldFiber, newChild, lanes) {
  const key = oldFiber !== null ? oldFiber.key : null;
  
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 文本节点没有key
    if (key !== null) {
      return null; // key不匹配
    }
    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
  }
  
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE: {
        if (newChild.key === key) {
          // key匹配，检查type
          if (newChild.type === REACT_FRAGMENT_TYPE) {
            return updateFragment(
              returnFiber,
              oldFiber,
              newChild.props.children,
              lanes,
              key
            );
          }
          return updateElement(returnFiber, oldFiber, newChild, lanes);
        } else {
          return null; // key不匹配
        }
      }
    }
    
    if (isArray(newChild) || getIteratorFn(newChild)) {
      if (key !== null) {
        return null; // 数组没有key
      }
      return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
    }
  }
  
  return null;
}

// mapRemainingChildren：为剩余节点建立key映射
function mapRemainingChildren(returnFiber, currentFirstChild) {
  const existingChildren = new Map();
  
  let existingChild = currentFirstChild;
  while (existingChild !== null) {
    if (existingChild.key !== null) {
      existingChildren.set(existingChild.key, existingChild);
    } else {
      existingChildren.set(existingChild.index, existingChild);
    }
    existingChild = existingChild.sibling;
  }
  
  return existingChildren;
}

// updateFromMap：从map中查找可复用的节点
function updateFromMap(
  existingChildren,
  returnFiber,
  newIdx,
  newChild,
  lanes
) {
  if (typeof newChild === 'string' || typeof newChild === 'number') {
    const matchedFiber = existingChildren.get(newIdx) || null;
    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
  }
  
  if (typeof newChild === 'object' && newChild !== null) {
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE: {
        const matchedFiber = existingChildren.get(
          newChild.key === null ? newIdx : newChild.key
        ) || null;
        
        if (newChild.type === REACT_FRAGMENT_TYPE) {
          return updateFragment(
            returnFiber,
            matchedFiber,
            newChild.props.children,
            lanes,
            newChild.key
          );
        }
        
        return updateElement(returnFiber, matchedFiber, newChild, lanes);
      }
    }
  }
  
  return null;
}
```

### 9.5 协调过程的优化策略

#### 双缓存机制
```javascript
// 双缓存Fiber树
function createWorkInProgress(current, pendingProps) {
  let workInProgress = current.alternate;
  
  if (workInProgress === null) {
    // 首次渲染，创建workInProgress树
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;
    
    // 建立双向连接
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    // 更新渲染，复用workInProgress树
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    
    // 清除副作用
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }
  
  // 复制其他属性
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;
  
  return workInProgress;
}

// 树的切换
function commitRoot(root) {
  const finishedWork = root.finishedWork;
  const lanes = root.finishedLanes;
  
  // 执行DOM操作
  commitMutationEffects(root, finishedWork, lanes);
  
  // 切换current树
  root.current = finishedWork;
  
  // 执行layout effects
  commitLayoutEffects(finishedWork, root, lanes);
}
```

#### 跳过子树的优化
```javascript
// bailout策略：跳过没有变化的子树
function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // 复用current的子节点
    workInProgress.child = current.child;
  }
  
  // 检查子树是否有更新
  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // 子树没有更新，可以跳过
    return null;
  } else {
    // 子树有更新，需要继续处理
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}

// 组件级别的bailout
function updateFunctionComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  renderLanes
) {
  // 检查props是否变化
  if (current !== null && !didReceiveUpdate) {
    // props没有变化，尝试bailout
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  
  // 执行函数组件
  const nextChildren = renderWithHooks(
    current,
    workInProgress,
    Component,
    nextProps,
    context,
    renderLanes
  );
  
  // 协调子节点
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  return workInProgress.child;
}

// React.memo的实现
function updateMemoComponent(
  current,
  workInProgress,
  Component,
  nextProps,
  updateLanes,
  renderLanes
) {
  if (current === null) {
    // 首次渲染
    const type = Component.type;
    if (isSimpleFunctionComponent(type) && Component.compare === null) {
      // 简单函数组件，直接渲染
      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = type;
      return updateSimpleMemoComponent(
        current,
        workInProgress,
        type,
        nextProps,
        updateLanes,
        renderLanes
      );
    }
  }
  
  const type = Component.type;
  const prevProps = current !== null ? current.memoizedProps : null;
  
  // 比较props
  if (
    current !== null &&
    (Component.compare !== null
      ? Component.compare(prevProps, nextProps)
      : shallowEqual(prevProps, nextProps)) &&
    current.ref === workInProgress.ref
  ) {
    // props相同，bailout
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  
  // props不同，重新渲染
  const nextChildren = type(nextProps);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  
  return workInProgress.child;
}
```

## 10. 并发特性 (Concurrent Features) ⭐⭐⭐

### 10.1 并发模式概述

#### 什么是并发模式
并发模式是React 18引入的一套新特性，它允许React在渲染过程中被中断，从而让出主线程给更高优先级的任务，提升用户体验。

```javascript
// 并发模式的核心：可中断的渲染
function workLoopConcurrent() {
  // 只要还有工作要做，并且没有更高优先级的任务
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

// 时间切片的实现
function shouldYield() {
  const currentTime = getCurrentTime();
  
  // 检查是否超过了时间片
  if (currentTime >= deadline) {
    return true;
  }
  
  // 检查是否有更高优先级的任务
  if (hasHigherPriorityWork()) {
    return true;
  }
  
  return false;
}

// 调度器的优先级系统
const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;

function scheduleCallback(priorityLevel, callback) {
  const currentTime = getCurrentTime();
  const timeout = timeoutForPriorityLevel(priorityLevel);
  const expirationTime = currentTime + timeout;
  
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime: currentTime,
    expirationTime,
    sortIndex: expirationTime,
  };
  
  // 根据优先级插入到不同的队列
  if (priorityLevel === ImmediatePriority) {
    // 立即执行
    flushSyncCallbackQueue();
  } else {
    // 加入调度队列
    push(taskQueue, newTask);
    requestHostCallback(flushWork);
  }
  
  return newTask;
}
```

### 10.2 时间切片 (Time Slicing)

#### 时间切片的实现原理
```javascript
// 时间切片的核心实现
let yieldInterval = 5; // 5ms的时间片
let deadline = 0;

function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    schedulePerformWorkUntilDeadline();
  }
}

function schedulePerformWorkUntilDeadline() {
  if (typeof MessageChannel !== 'undefined') {
    // 使用MessageChannel实现异步调度
    const channel = new MessageChannel();
    const port = channel.port2;
    
    channel.port1.onmessage = performWorkUntilDeadline;
    
    schedulePerformWorkUntilDeadline = () => {
      port.postMessage(null);
    };
  } else {
    // 降级到setTimeout
    schedulePerformWorkUntilDeadline = () => {
      setTimeout(performWorkUntilDeadline, 0);
    };
  }
}

function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    deadline = currentTime + yieldInterval;
    
    const hasTimeRemaining = true;
    let hasMoreWork = true;
    
    try {
      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
    } finally {
      if (hasMoreWork) {
        // 还有工作要做，继续调度
        schedulePerformWorkUntilDeadline();
      } else {
        isMessageLoopRunning = false;
        scheduledHostCallback = null;
      }
    }
  } else {
    isMessageLoopRunning = false;
  }
}

// 工作循环的实现
function flushWork(hasTimeRemaining, initialTime) {
  isHostCallbackScheduled = false;
  
  if (isHostTimeoutScheduled) {
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }
  
  isPerformingWork = true;
  const previousPriorityLevel = currentPriorityLevel;
  
  try {
    return workLoop(hasTimeRemaining, initialTime);
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}

function workLoop(hasTimeRemaining, initialTime) {
  let currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);
  
  while (currentTask !== null && !enableSchedulerDebugging) {
    if (
      currentTask.expirationTime > currentTime &&
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      // 时间片用完，让出控制权
      break;
    }
    
    const callback = currentTask.callback;
    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      
      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
      const continuationCallback = callback(didUserCallbackTimeout);
      
      currentTime = getCurrentTime();
      
      if (typeof continuationCallback === 'function') {
        // 任务还没完成，继续执行
        currentTask.callback = continuationCallback;
      } else {
        // 任务完成，从队列中移除
        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }
      
      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }
    
    currentTask = peek(taskQueue);
  }
  
  // 返回是否还有更多工作
  if (currentTask !== null) {
    return true;
  } else {
    const firstTimer = peek(timerQueue);
    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
    return false;
  }
}
```

### 10.3 useTransition Hook

#### useTransition的实现原理
```javascript
// useTransition的实现
function useTransition() {
  const [isPending, setPending] = useState(false);
  const startTransition = useCallback((callback) => {
    setPending(true);
    
    // 将更新标记为transition
    const prevTransition = ReactCurrentBatchConfig.transition;
    ReactCurrentBatchConfig.transition = {
      _updatedFibers: new Set(),
    };
    
    try {
      setPending(false);
      callback();
    } finally {
      ReactCurrentBatchConfig.transition = prevTransition;
    }
  }, []);
  
  return [isPending, startTransition];
}

// 在调度器中处理transition
function scheduleUpdateOnFiber(fiber, lane, eventTime) {
  const root = markUpdateLaneFromFiberToRoot(fiber, lane);
  
  if (lane === SyncLane) {
    // 同步更新，立即执行
    if (
      (executionContext & LegacyUnbatchedContext) !== NoContext &&
      (executionContext & (RenderContext | CommitContext)) === NoContext
    ) {
      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root, eventTime);
    }
  } else {
    // 异步更新，根据优先级调度
    if (isTransition(lane)) {
      // Transition更新，使用较低优先级
      ensureRootIsScheduled(root, eventTime);
    } else {
      // 普通更新
      ensureRootIsScheduled(root, eventTime);
    }
  }
}

// 实际使用示例
function SearchApp() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();
  
  const handleSearch = (value) => {
    // 立即更新输入框（高优先级）
    setQuery(value);
    
    // 延迟更新搜索结果（低优先级）
    startTransition(() => {
      const searchResults = performExpensiveSearch(value);
      setResults(searchResults);
    });
  };
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
        placeholder="搜索..."
      />
      {isPending && <div>搜索中...</div>}
      <SearchResults results={results} />
    </div>
  );
}

// 性能对比示例
function WithoutTransition() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const handleSearch = (value) => {
    setQuery(value);
    // 所有更新都是同步的，可能导致输入卡顿
    const searchResults = performExpensiveSearch(value);
    setResults(searchResults);
  };
  
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => handleSearch(e.target.value)}
      />
      <SearchResults results={results} />
    </div>
  );
}
```

### 10.4 useDeferredValue Hook

#### useDeferredValue的实现原理
```javascript
// useDeferredValue的实现
function useDeferredValue(value) {
  const [prevValue, setValue] = useState(value);
  
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      startTransition(() => {
        setValue(value);
      });
    }, 0);
    
    return () => clearTimeout(timeoutId);
  }, [value]);
  
  return prevValue;
}

// 更精确的实现（React内部）
function useDeferredValue(value) {
  const hook = updateWorkInProgressHook();
  const prevValue = hook.memoizedState;
  
  if (prevValue !== value) {
    // 值发生变化，调度一个低优先级更新
    const deferredLane = requestDeferredLane();
    
    scheduleUpdateOnFiber(
      currentlyRenderingFiber,
      deferredLane,
      getCurrentTime()
    );
    
    hook.memoizedState = value;
  }
  
  return prevValue;
}

// 使用示例
function ProductList({ searchQuery }) {
  // 延迟搜索查询，避免频繁的列表更新
  const deferredQuery = useDeferredValue(searchQuery);
  const products = useMemo(() => {
    return searchProducts(deferredQuery);
  }, [deferredQuery]);
  
  return (
    <div>
      {/* 显示当前输入 */}
      <div>搜索: {searchQuery}</div>
      
      {/* 显示延迟的结果 */}
      {searchQuery !== deferredQuery && (
        <div>正在搜索 "{searchQuery}"...</div>
      )}
      
      <ul>
        {products.map(product => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
}

// 性能优化示例
function OptimizedApp() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  
  return (
    <div>
      {/* 输入框立即响应 */}
      <input 
        value={text}
        onChange={(e) => setText(e.target.value)}
      />
      
      {/* 昂贵的组件使用延迟值 */}
      <ExpensiveComponent text={deferredText} />
    </div>
  );
}

function ExpensiveComponent({ text }) {
  // 模拟昂贵的计算
  const expensiveValue = useMemo(() => {
    let result = 0;
    for (let i = 0; i < 100000; i++) {
      result += text.length;
    }
    return result;
  }, [text]);
  
  return <div>计算结果: {expensiveValue}</div>;
}
```

### 10.5 Suspense for Data Fetching

#### Suspense的实现原理
```javascript
// Suspense组件的实现
function Suspense({ children, fallback }) {
  const [isLoading, setIsLoading] = useState(false);
  
  return (
    <SuspenseContext.Provider value={{ setIsLoading }}>
      {isLoading ? fallback : children}
    </SuspenseContext.Provider>
  );
}

// React内部的Suspense实现
function updateSuspenseComponent(
  current,
  workInProgress,
  renderLanes
) {
  const nextProps = workInProgress.pendingProps;
  
  // 检查是否有suspended的子组件
  let suspenseContext = suspenseStackCursor.current;
  let showFallback = false;
  
  const didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;
  
  if (didSuspend || shouldRemainOnFallback(suspenseContext, current, workInProgress)) {
    // 显示fallback
    showFallback = true;
    workInProgress.flags &= ~DidCapture;
  } else {
    // 尝试渲染children
    if (current === null || (current.memoizedState !== null)) {
      suspenseContext = addSubtreeSuspenseContext(
        suspenseContext,
        InvisibleParentSuspenseContext
      );
    }
  }
  
  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  pushSuspenseContext(workInProgress, suspenseContext);
  
  if (showFallback) {
    // 渲染fallback
    const nextFallbackChildren = nextProps.fallback;
    const nextPrimaryChildren = nextProps.children;
    
    const fallbackFragment = createFiberFromFragment(
      nextFallbackChildren,
      workInProgress.mode,
      renderLanes,
      null
    );
    
    const primaryFragment = createFiberFromFragment(
      nextPrimaryChildren,
      workInProgress.mode,
      OffscreenLane,
      null
    );
    
    fallbackFragment.return = workInProgress;
    primaryFragment.return = workInProgress;
    fallbackFragment.sibling = primaryFragment;
    
    workInProgress.child = fallbackFragment;
    
    return fallbackFragment;
  } else {
    // 渲染children
    const nextPrimaryChildren = nextProps.children;
    const primaryChild = createFiberFromFragment(
      nextPrimaryChildren,
      workInProgress.mode,
      renderLanes,
      null
    );
    
    primaryChild.return = workInProgress;
    workInProgress.child = primaryChild;
    
    return primaryChild;
  }
}

// 数据获取的Suspense实现
function createResource(promise) {
  let status = 'pending';
  let result;
  
  const suspender = promise.then(
    (data) => {
      status = 'success';
      result = data;
    },
    (error) => {
      status = 'error';
      result = error;
    }
  );
  
  return {
    read() {
      if (status === 'pending') {
        throw suspender; // 抛出Promise，触发Suspense
      } else if (status === 'error') {
        throw result;
      } else if (status === 'success') {
        return result;
      }
    }
  };
}

// 使用示例
function UserProfile({ userId }) {
  const user = userResource.read(); // 可能抛出Promise
  
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

function App() {
  return (
    <Suspense fallback={<div>加载用户信息...</div>}>
      <UserProfile userId={1} />
    </Suspense>
  );
}

// 错误边界与Suspense结合
function DataFetcher({ userId }) {
  return (
    <ErrorBoundary fallback={<div>加载失败</div>}>
      <Suspense fallback={<div>加载中...</div>}>
        <UserProfile userId={userId} />
      </Suspense>
    </ErrorBoundary>
  );
}
```

### 10.6 并发特性的优势与挑战

#### 优势
```javascript
// 1. 更好的用户体验
function ResponsiveApp() {
  const [count, setCount] = useState(0);
  const [isPending, startTransition] = useTransition();
  
  const handleClick = () => {
    // 立即更新计数器
    setCount(c => c + 1);
    
    // 延迟执行昂贵的操作
    startTransition(() => {
      performExpensiveOperation();
    });
  };
  
  return (
    <div>
      <button onClick={handleClick}>
        点击次数: {count}
      </button>
      {isPending && <div>处理中...</div>}
    </div>
  );
}

// 2. 更好的性能
function PerformantList({ items }) {
  const deferredItems = useDeferredValue(items);
  
  return (
    <div>
      {/* 立即显示项目数量 */}
      <div>共 {items.length} 项</div>
      
      {/* 延迟渲染列表 */}
      <VirtualizedList items={deferredItems} />
    </div>
  );
}
```

#### 挑战与注意事项
```javascript
// 1. 状态一致性问题
function InconsistentState() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  // 注意：query和deferredQuery可能不一致
  return (
    <div>
      <input 
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />
      {/* 需要处理状态不一致的情况 */}
      {query !== deferredQuery && (
        <div>正在更新...</div>
      )}
      <SearchResults query={deferredQuery} />
    </div>
  );
}

// 2. 调试复杂性
function DebuggingConcurrency() {
  // 并发特性可能使调试变得复杂
  // 需要使用React DevTools的Profiler
  
  const [isPending, startTransition] = useTransition();
  
  useEffect(() => {
    // 在开发环境中添加日志
    if (process.env.NODE_ENV === 'development') {
      console.log('Transition pending:', isPending);
    }
  }, [isPending]);
  
  return (
    <div>
      {/* 组件内容 */}
    </div>
  );
}

// 3. 向后兼容性
function BackwardCompatibility() {
  // 检查是否支持并发特性
  const supportsTransition = typeof useTransition === 'function';
  
  if (supportsTransition) {
    const [isPending, startTransition] = useTransition();
    // 使用并发特性
  } else {
    // 降级到传统方式
  }
}
```

## 11. 服务端渲染 (SSR) ⭐⭐⭐

### 11.1 SSR核心概念

#### 什么是服务端渲染
服务端渲染是指在服务器上执行React组件，生成HTML字符串，然后发送给客户端的技术。客户端接收到HTML后，React会进行"水合"(hydration)过程，使静态HTML变成可交互的应用。

```javascript
// 服务端渲染的基本流程
const express = require('express');
const React = require('react');
const ReactDOMServer = require('react-dom/server');
const App = require('./App');

const server = express();

server.get('/', (req, res) => {
  // 1. 在服务端渲染React组件
  const html = ReactDOMServer.renderToString(
    React.createElement(App, { url: req.url })
  );
  
  // 2. 生成完整的HTML页面
  const fullHtml = `
    <!DOCTYPE html>
    <html>
      <head>
        <title>SSR App</title>
        <script>window.__INITIAL_DATA__ = ${JSON.stringify(initialData)}</script>
      </head>
      <body>
        <div id="root">${html}</div>
        <script src="/bundle.js"></script>
      </body>
    </html>
  `;
  
  // 3. 发送HTML给客户端
  res.send(fullHtml);
});

server.listen(3000);
```

### 11.2 renderToString的实现原理

#### renderToString的核心实现
```javascript
// React DOM Server的renderToString实现
function renderToString(element) {
  const markup = renderToStringImpl(element, false);
  return markup;
}

function renderToStringImpl(child, context, makeStaticMarkup) {
  if (child === null || child === undefined || typeof child === 'boolean') {
    return '';
  }
  
  if (typeof child === 'string' || typeof child === 'number') {
    return escapeTextForBrowser(child);
  }
  
  if (Array.isArray(child)) {
    let markup = '';
    for (let i = 0; i < child.length; i++) {
      markup += renderToStringImpl(child[i], context, makeStaticMarkup);
    }
    return markup;
  }
  
  if (typeof child === 'object') {
    if (child.$$typeof === REACT_ELEMENT_TYPE) {
      return renderElement(child, context, makeStaticMarkup);
    }
  }
  
  throw new Error('Invalid child type');
}

function renderElement(element, context, makeStaticMarkup) {
  const { type, props } = element;
  
  if (typeof type === 'string') {
    // 原生DOM元素
    return renderDOMElement(element, context, makeStaticMarkup);
  } else if (typeof type === 'function') {
    // React组件
    return renderComponent(element, context, makeStaticMarkup);
  }
  
  throw new Error('Invalid element type');
}

// 渲染DOM元素
function renderDOMElement(element, context, makeStaticMarkup) {
  const { type: tag, props } = element;
  let markup = '<' + tag;
  
  // 处理属性
  for (const propName in props) {
    if (propName === 'children') continue;
    
    const propValue = props[propName];
    if (propValue === null || propValue === undefined) continue;
    
    if (propName === 'style') {
      // 处理样式对象
      const styleStr = Object.keys(propValue)
        .map(key => `${kebabCase(key)}:${propValue[key]}`)
        .join(';');
      markup += ` style="${escapeTextForBrowser(styleStr)}"`;
    } else if (propName === 'className') {
      markup += ` class="${escapeTextForBrowser(propValue)}"`;
    } else if (isValidAttribute(propName)) {
      markup += ` ${propName}="${escapeTextForBrowser(propValue)}"`;
    }
  }
  
  // 自闭合标签
  if (isVoidElement(tag)) {
    markup += '/>';
    return markup;
  }
  
  markup += '>';
  
  // 渲染子元素
  const children = props.children;
  if (children !== null && children !== undefined) {
    markup += renderToStringImpl(children, context, makeStaticMarkup);
  }
  
  markup += '</' + tag + '>';
  return markup;
}

// 渲染React组件
function renderComponent(element, context, makeStaticMarkup) {
  const { type: Component, props } = element;
  
  if (Component.prototype && Component.prototype.isReactComponent) {
    // 类组件
    const instance = new Component(props, context);
    
    // 调用生命周期方法
    if (instance.componentWillMount) {
      instance.componentWillMount();
    }
    
    const renderedElement = instance.render();
    return renderToStringImpl(renderedElement, context, makeStaticMarkup);
  } else {
    // 函数组件
    const renderedElement = Component(props, context);
    return renderToStringImpl(renderedElement, context, makeStaticMarkup);
  }
}

// HTML转义
function escapeTextForBrowser(text) {
  return String(text)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;');
}
```

### 11.3 Hydration水合过程

#### 客户端水合的实现
```javascript
// ReactDOM.hydrate的实现
function hydrate(element, container, callback) {
  return legacyRenderSubtreeIntoContainer(
    null,
    element,
    container,
    true, // forceHydrate = true
    callback
  );
}

function legacyRenderSubtreeIntoContainer(
  parentComponent,
  children,
  container,
  forceHydrate,
  callback
) {
  let root = container._reactRootContainer;
  
  if (!root) {
    // 创建根容器
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate
    );
    
    if (forceHydrate) {
      // 水合模式
      root.hydrate(children, callback);
    } else {
      // 普通渲染模式
      root.render(children, callback);
    }
  }
  
  return getPublicRootInstance(root._internalRoot);
}

// 水合过程的核心逻辑
function hydrateRoot(container, children) {
  const rootFiber = createFiberRoot(container, ConcurrentRoot);
  
  // 标记为水合模式
  rootFiber.hydrationCallbacks = {
    onHydrated: () => console.log('Hydration completed'),
    onDeleted: () => console.log('Node deleted during hydration')
  };
  
  // 开始水合过程
  updateContainer(children, rootFiber, null, null);
  
  return rootFiber;
}

// 水合时的节点比较
function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent: {
      const type = fiber.type;
      const props = fiber.pendingProps;
      
      // 检查节点类型是否匹配
      if (nextInstance.nodeType !== ELEMENT_NODE || 
          nextInstance.nodeName.toLowerCase() !== type.toLowerCase()) {
        return null;
      }
      
      // 检查属性是否匹配
      const instance = nextInstance;
      hydrateInstance(instance, type, props, fiber);
      
      return instance;
    }
    
    case HostText: {
      const text = fiber.pendingProps;
      
      if (nextInstance.nodeType !== TEXT_NODE) {
        return null;
      }
      
      const textInstance = nextInstance;
      hydrateTextInstance(textInstance, text, fiber);
      
      return textInstance;
    }
    
    default:
      return null;
  }
}

// 水合DOM实例
function hydrateInstance(instance, type, props, fiber) {
  // 更新属性
  updateProperties(instance, type, {}, props);
  
  // 标记为已水合
  markNodeAsHoisted(instance);
  
  // 检查属性不匹配的情况
  if (process.env.NODE_ENV !== 'production') {
    validatePropertiesInDevelopment(type, props, instance);
  }
}

// 水合文本实例
function hydrateTextInstance(textInstance, text, fiber) {
  const shouldUpdate = textInstance.nodeValue !== text;
  
  if (shouldUpdate) {
    // 文本不匹配，需要更新
    if (process.env.NODE_ENV !== 'production') {
      console.warn(
        'Text content did not match. Server: "%s" Client: "%s"',
        textInstance.nodeValue,
        text
      );
    }
    
    textInstance.nodeValue = text;
  }
}
```

### 11.4 同构应用的实现

#### 通用组件的编写
```javascript
// 通用的数据获取组件
class UniversalComponent extends React.Component {
  constructor(props) {
    super(props);
    
    // 服务端和客户端都需要的初始状态
    this.state = {
      data: props.initialData || null,
      loading: !props.initialData,
      error: null
    };
  }
  
  componentDidMount() {
    // 只在客户端执行
    if (!this.state.data) {
      this.fetchData();
    }
  }
  
  async fetchData() {
    try {
      this.setState({ loading: true });
      const data = await fetch('/api/data').then(res => res.json());
      this.setState({ data, loading: false });
    } catch (error) {
      this.setState({ error, loading: false });
    }
  }
  
  render() {
    const { data, loading, error } = this.state;
    
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    if (!data) return <div>No data</div>;
    
    return (
      <div>
        <h1>{data.title}</h1>
        <p>{data.content}</p>
      </div>
    );
  }
}

// 服务端数据预取
async function getServerSideProps(context) {
  try {
    const data = await fetchDataFromAPI(context.params.id);
    return {
      props: {
        initialData: data
      }
    };
  } catch (error) {
    return {
      props: {
        initialData: null
      }
    };
  }
}

// 客户端入口
function ClientApp() {
  const initialData = window.__INITIAL_DATA__;
  
  return (
    <BrowserRouter>
      <Routes>
        <Route 
          path="/" 
          element={<UniversalComponent initialData={initialData} />} 
        />
      </Routes>
    </BrowserRouter>
  );
}

// 服务端入口
function ServerApp({ url, initialData }) {
  return (
    <StaticRouter location={url}>
      <Routes>
        <Route 
          path="/" 
          element={<UniversalComponent initialData={initialData} />} 
        />
      </Routes>
    </StaticRouter>
  );
}
```

### 11.5 SSR的性能优化

#### 流式渲染
```javascript
// renderToNodeStream的实现
function renderToNodeStream(element) {
  const stream = new Readable({
    read() {}
  });
  
  const context = {
    stream,
    hasError: false
  };
  
  // 异步渲染
  setImmediate(() => {
    try {
      renderToStreamImpl(element, context);
    } catch (error) {
      context.hasError = true;
      stream.emit('error', error);
    }
  });
  
  return stream;
}

function renderToStreamImpl(element, context) {
  const { stream } = context;
  
  function flushChunk(chunk) {
    if (!context.hasError) {
      stream.push(chunk);
    }
  }
  
  function renderElementToStream(element) {
    if (typeof element === 'string' || typeof element === 'number') {
      flushChunk(escapeTextForBrowser(element));
      return;
    }
    
    if (React.isValidElement(element)) {
      const { type, props } = element;
      
      if (typeof type === 'string') {
        // DOM元素
        flushChunk(`<${type}`);
        
        // 渲染属性
        for (const prop in props) {
          if (prop !== 'children' && props[prop] != null) {
            flushChunk(` ${prop}="${escapeTextForBrowser(props[prop])}"`);
          }
        }
        
        flushChunk('>');
        
        // 渲染子元素
        if (props.children) {
          renderElementToStream(props.children);
        }
        
        flushChunk(`</${type}>`);
      } else if (typeof type === 'function') {
        // React组件
        const rendered = type(props);
        renderElementToStream(rendered);
      }
    } else if (Array.isArray(element)) {
      element.forEach(renderElementToStream);
    }
  }
  
  renderElementToStream(element);
  stream.push(null); // 结束流
}

// 使用流式渲染
app.get('/', (req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  
  // 发送HTML头部
  res.write(`
    <!DOCTYPE html>
    <html>
      <head><title>Streaming SSR</title></head>
      <body>
        <div id="root">
  `);
  
  // 流式渲染React组件
  const stream = renderToNodeStream(<App />);
  
  stream.on('data', chunk => {
    res.write(chunk);
  });
  
  stream.on('end', () => {
    res.write(`
        </div>
        <script src="/bundle.js"></script>
      </body>
    </html>
    `);
    res.end();
  });
  
  stream.on('error', error => {
    console.error('Stream error:', error);
    res.end();
  });
});
```

#### 组件级缓存
```javascript
// 组件缓存装饰器
function withSSRCache(Component, cacheKey) {
  const cache = new Map();
  
  return function CachedComponent(props) {
    const key = typeof cacheKey === 'function' 
      ? cacheKey(props) 
      : JSON.stringify(props);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const rendered = <Component {...props} />;
    cache.set(key, rendered);
    
    // 设置缓存过期时间
    setTimeout(() => {
      cache.delete(key);
    }, 5 * 60 * 1000); // 5分钟
    
    return rendered;
  };
}

// 使用缓存
const CachedUserProfile = withSSRCache(
  UserProfile,
  (props) => `user-${props.userId}`
);

// 页面级缓存
const pageCache = new Map();

app.get('*', (req, res) => {
  const cacheKey = req.url;
  
  if (pageCache.has(cacheKey)) {
    const cachedHtml = pageCache.get(cacheKey);
    res.send(cachedHtml);
    return;
  }
  
  const html = renderToString(<App url={req.url} />);
  const fullHtml = generateFullHTML(html);
  
  // 缓存页面
  pageCache.set(cacheKey, fullHtml);
  
  // 设置缓存过期
  setTimeout(() => {
    pageCache.delete(cacheKey);
  }, 10 * 60 * 1000); // 10分钟
  
  res.send(fullHtml);
});
```

### 11.6 SSR的挑战与解决方案

#### 客户端和服务端差异处理
```javascript
// 环境检测
const isServer = typeof window === 'undefined';
const isBrowser = typeof window !== 'undefined';

// 条件渲染
function ConditionalComponent() {
  const [mounted, setMounted] = useState(false);
  
  useEffect(() => {
    setMounted(true);
  }, []);
  
  // 避免服务端和客户端渲染不一致
  if (!mounted) {
    return <div>Loading...</div>;
  }
  
  return (
    <div>
      {isBrowser && (
        <div>只在客户端显示的内容</div>
      )}
    </div>
  );
}

// 动态导入
function DynamicComponent() {
  const [Component, setComponent] = useState(null);
  
  useEffect(() => {
    if (isBrowser) {
      import('./ClientOnlyComponent').then(module => {
        setComponent(() => module.default);
      });
    }
  }, []);
  
  if (!Component) {
    return <div>Loading component...</div>;
  }
  
  return <Component />;
}

// 状态同步
function StateSync() {
  // 从服务端传递的初始状态
  const initialState = isBrowser 
    ? window.__INITIAL_STATE__ 
    : {};
  
  const [state, setState] = useState(initialState);
  
  // 清理全局状态，避免内存泄漏
  useEffect(() => {
    if (isBrowser && window.__INITIAL_STATE__) {
      delete window.__INITIAL_STATE__;
    }
  }, []);
  
  return (
    <div>
      <pre>{JSON.stringify(state, null, 2)}</pre>
    </div>
  );
}
```

#### 错误处理和降级
```javascript
// SSR错误边界
class SSRErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    // 在服务端记录错误
    if (isServer) {
      console.error('SSR Error:', error, errorInfo);
    }
  }
  
  render() {
    if (this.state.hasError) {
      // 降级到客户端渲染
      return (
        <div id="root">
          <script>
            {`
              // 客户端渲染降级
              window.__SSR_ERROR__ = true;
              ReactDOM.render(
                React.createElement(App),
                document.getElementById('root')
              );
            `}
          </script>
        </div>
      );
    }
    
    return this.props.children;
  }
}

// 服务端错误处理
app.get('*', async (req, res) => {
  try {
    const html = await renderToString(
      <SSRErrorBoundary>
        <App url={req.url} />
      </SSRErrorBoundary>
    );
    
    res.send(generateFullHTML(html));
  } catch (error) {
    console.error('SSR failed:', error);
    
    // 降级到客户端渲染
    const fallbackHTML = `
      <!DOCTYPE html>
      <html>
        <head><title>App</title></head>
        <body>
          <div id="root"></div>
          <script src="/bundle.js"></script>
          <script>
            // 标记SSR失败
            window.__SSR_FAILED__ = true;
          </script>
        </body>
      </html>
    `;
    
    res.send(fallbackHTML);
  }
});
```

## 12. 错误边界 (Error Boundaries) ⭐⭐⭐

### 12.1 错误边界核心概念

#### 什么是错误边界
错误边界是一种React组件，它可以捕获并打印发生在其子组件树任何位置的JavaScript错误，并且，它会渲染出备用UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。

```javascript
// 错误边界的基本实现
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false, 
      error: null, 
      errorInfo: null 
    };
  }

  // 静态方法，用于更新state以显示降级UI
  static getDerivedStateFromError(error) {
    // 更新state使下一次渲染能够显示降级后的UI
    return { hasError: true };
  }

  // 生命周期方法，用于记录错误信息
  componentDidCatch(error, errorInfo) {
    // 你同样可以将错误日志上报给服务器
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
    
    // 错误上报
    this.logErrorToService(error, errorInfo);
  }

  logErrorToService(error, errorInfo) {
    // 发送错误信息到监控服务
    console.error('Error Boundary caught an error:', error, errorInfo);
    
    // 实际项目中可能会发送到Sentry、LogRocket等服务
    // Sentry.captureException(error, { extra: errorInfo });
  }

  render() {
    if (this.state.hasError) {
      // 你可以自定义降级后的UI并渲染
      return (
        <div className="error-boundary">
          <h2>哎呀！出了点问题</h2>
          <details style={{ whiteSpace: 'pre-wrap' }}>
            {this.state.error && this.state.error.toString()}
            <br />
            {this.state.errorInfo.componentStack}
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 12.2 错误边界的实现原理

#### React内部的错误处理机制
```javascript
// React内部的错误捕获实现
function captureCommitPhaseError(fiber, error) {
  const errorInfo = createCapturedValue(error, fiber);
  const update = createUpdate(NoTimestamp, SyncLane);
  update.payload = { element: null };
  update.callback = () => {
    markFailedErrorBoundaryForHotReloading(fiber);
    logCapturedError(errorInfo);
  };
  
  enqueueUpdate(fiber, update);
  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
}

// 查找最近的错误边界
function findNearestErrorBoundary(fiber) {
  let node = fiber.return;
  
  while (node !== null) {
    if (isErrorBoundary(node)) {
      return node;
    }
    node = node.return;
  }
  
  return null;
}

// 检查是否为错误边界
function isErrorBoundary(fiber) {
  const { type, tag } = fiber;
  
  if (tag === ClassComponent) {
    const instance = fiber.stateNode;
    return (
      typeof instance.componentDidCatch === 'function' ||
      typeof type.getDerivedStateFromError === 'function'
    );
  }
  
  return false;
}

// 处理错误边界的错误
function handleErrorBoundary(errorBoundary, error, errorInfo) {
  const instance = errorBoundary.stateNode;
  const ctor = errorBoundary.type;
  
  // 调用getDerivedStateFromError
  if (typeof ctor.getDerivedStateFromError === 'function') {
    const newState = ctor.getDerivedStateFromError(error);
    
    // 更新错误边界的state
    const update = createUpdate(NoTimestamp, SyncLane);
    update.payload = newState;
    enqueueUpdate(errorBoundary, update);
  }
  
  // 调用componentDidCatch
  if (typeof instance.componentDidCatch === 'function') {
    instance.componentDidCatch(error, errorInfo);
  }
}

// 错误信息的创建
function createCapturedValue(value, source) {
  return {
    value,
    source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

// 获取组件堆栈信息
function getStackByFiberInDevAndProd(fiber) {
  let stack = '';
  let node = fiber;
  
  do {
    stack += describeComponentFrame(node);
    node = node.return;
  } while (node);
  
  return stack;
}

function describeComponentFrame(fiber) {
  const { type, tag } = fiber;
  let name = null;
  
  if (tag === ClassComponent || tag === FunctionComponent) {
    name = type.displayName || type.name || 'Unknown';
  }
  
  return `\n    in ${name || 'Unknown'}`;
}
```

### 12.3 高级错误边界实现

#### 带有重试功能的错误边界
```javascript
class RetryErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
    
    // 错误上报
    this.reportError(error, errorInfo);
  }

  reportError = (error, errorInfo) => {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      userId: this.props.userId,
      retryCount: this.state.retryCount
    };
    
    // 发送到错误监控服务
    fetch('/api/errors', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(errorReport)
    }).catch(err => {
      console.error('Failed to report error:', err);
    });
  }

  handleRetry = () => {
    this.setState(prevState => ({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: prevState.retryCount + 1
    }));
  }

  render() {
    if (this.state.hasError) {
      const { retryCount } = this.state;
      const maxRetries = 3;
      
      return (
        <div className="error-boundary-container">
          <div className="error-content">
            <h2>🚨 应用遇到了错误</h2>
            <p>我们已经记录了这个问题，正在努力修复。</p>
            
            {retryCount < maxRetries && (
              <button 
                onClick={this.handleRetry}
                className="retry-button"
              >
                重试 ({retryCount + 1}/{maxRetries})
              </button>
            )}
            
            {retryCount >= maxRetries && (
              <div>
                <p>多次重试失败，请刷新页面或联系技术支持。</p>
                <button onClick={() => window.location.reload()}>
                  刷新页面
                </button>
              </div>
            )}
            
            {process.env.NODE_ENV === 'development' && (
              <details className="error-details">
                <summary>错误详情 (开发模式)</summary>
                <pre>{this.state.error?.toString()}</pre>
                <pre>{this.state.errorInfo?.componentStack}</pre>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}
```

#### 异步错误边界
```javascript
// 由于错误边界无法捕获异步错误，需要特殊处理
class AsyncErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Sync error caught:', error, errorInfo);
  }

  componentDidMount() {
    // 监听未捕获的Promise rejection
    window.addEventListener('unhandledrejection', this.handlePromiseRejection);
    
    // 监听全局错误
    window.addEventListener('error', this.handleGlobalError);
  }

  componentWillUnmount() {
    window.removeEventListener('unhandledrejection', this.handlePromiseRejection);
    window.removeEventListener('error', this.handleGlobalError);
  }

  handlePromiseRejection = (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    
    // 检查错误是否来自当前组件树
    if (this.isErrorFromCurrentTree(event.reason)) {
      this.setState({
        hasError: true,
        error: event.reason
      });
      
      // 阻止默认的错误处理
      event.preventDefault();
    }
  }

  handleGlobalError = (event) => {
    console.error('Global error:', event.error);
    
    if (this.isErrorFromCurrentTree(event.error)) {
      this.setState({
        hasError: true,
        error: event.error
      });
    }
  }

  isErrorFromCurrentTree = (error) => {
    // 简单的启发式检查，实际项目中可能需要更复杂的逻辑
    return error && error.stack && 
           error.stack.includes(this.props.componentName || 'App');
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="async-error-boundary">
          <h2>异步操作出现错误</h2>
          <p>错误信息: {this.state.error?.message}</p>
          <button onClick={() => this.setState({ hasError: false, error: null })}>
            重置
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 12.4 错误边界的最佳实践

#### 分层错误边界策略
```javascript
// 应用级错误边界
class AppErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 应用级错误，通常是严重错误
    this.reportCriticalError(error, errorInfo);
  }

  reportCriticalError(error, errorInfo) {
    // 发送到错误监控服务，标记为高优先级
    console.error('Critical application error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="app-crash">
          <h1>应用遇到了严重错误</h1>
          <p>请刷新页面重试，如果问题持续存在，请联系技术支持。</p>
          <button onClick={() => window.location.reload()}>
            刷新页面
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 页面级错误边界
class PageErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 页面级错误，中等严重程度
    this.reportPageError(error, errorInfo);
  }

  reportPageError(error, errorInfo) {
    console.error('Page error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="page-error">
          <h2>页面加载失败</h2>
          <p>这个页面遇到了问题，但应用的其他部分仍然可用。</p>
          <button onClick={() => this.setState({ hasError: false })}>
            重试
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 组件级错误边界
class ComponentErrorBoundary extends React.Component {
  state = { hasError: false };

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 组件级错误，通常影响较小
    this.reportComponentError(error, errorInfo);
  }

  reportComponentError(error, errorInfo) {
    console.warn('Component error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="component-error">
          <p>这个组件暂时不可用</p>
          <button onClick={() => this.setState({ hasError: false })}>
            重新加载组件
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// 使用分层错误边界
function App() {
  return (
    <AppErrorBoundary>
      <Router>
        <Routes>
          <Route path="/" element={
            <PageErrorBoundary>
              <HomePage />
            </PageErrorBoundary>
          } />
          <Route path="/profile" element={
            <PageErrorBoundary>
              <ComponentErrorBoundary>
                <UserProfile />
              </ComponentErrorBoundary>
            </PageErrorBoundary>
          } />
        </Routes>
      </Router>
    </AppErrorBoundary>
  );
}
```

#### 错误边界的Hook实现
```javascript
// 虽然Hook无法直接实现错误边界，但可以创建辅助Hook
function useErrorHandler() {
  const [error, setError] = useState(null);
  
  const resetError = useCallback(() => {
    setError(null);
  }, []);
  
  const captureError = useCallback((error) => {
    setError(error);
  }, []);
  
  // 捕获异步错误
  useEffect(() => {
    const handleUnhandledRejection = (event) => {
      captureError(event.reason);
    };
    
    window.addEventListener('unhandledrejection', handleUnhandledRejection);
    
    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejection);
    };
  }, [captureError]);
  
  return { error, resetError, captureError };
}

// 错误边界Hook的使用
function ErrorBoundaryProvider({ children }) {
  const { error, resetError, captureError } = useErrorHandler();
  
  // 提供错误处理上下文
  const errorContext = useMemo(() => ({
    captureError,
    resetError
  }), [captureError, resetError]);
  
  if (error) {
    return (
      <div className="error-fallback">
        <h2>Something went wrong</h2>
        <pre>{error.message}</pre>
        <button onClick={resetError}>Try again</button>
      </div>
    );
  }
  
  return (
    <ErrorContext.Provider value={errorContext}>
      {children}
    </ErrorContext.Provider>
  );
}

const ErrorContext = createContext();

// 在组件中使用
function MyComponent() {
  const { captureError } = useContext(ErrorContext);
  
  const handleAsyncOperation = async () => {
    try {
      await riskyAsyncOperation();
    } catch (error) {
      captureError(error);
    }
  };
  
  return (
    <button onClick={handleAsyncOperation}>
      执行异步操作
    </button>
  );
}
```

### 12.5 错误边界的限制和解决方案

#### 错误边界无法捕获的错误类型
```javascript
// 1. 事件处理器中的错误
function EventHandlerExample() {
  const handleClick = () => {
    // 这个错误不会被错误边界捕获
    throw new Error('Event handler error');
  };
  
  // 解决方案：手动捕获
  const handleClickSafe = () => {
    try {
      riskyOperation();
    } catch (error) {
      console.error('Event handler error:', error);
      // 手动处理错误或上报
    }
  };
  
  return <button onClick={handleClickSafe}>Safe Click</button>;
}

// 2. 异步代码中的错误
function AsyncExample() {
  useEffect(() => {
    // 这个错误不会被错误边界捕获
    setTimeout(() => {
      throw new Error('Async error');
    }, 1000);
    
    // 解决方案：使用try-catch或Promise.catch
    const asyncOperation = async () => {
      try {
        await fetch('/api/data');
      } catch (error) {
        console.error('Async error:', error);
        // 手动处理错误
      }
    };
    
    asyncOperation();
  }, []);
  
  return <div>Async Component</div>;
}

// 3. 服务端渲染中的错误
// 错误边界在服务端渲染时行为不同
function SSRErrorHandling() {
  // 在服务端，错误边界会将错误转换为字符串
  // 需要特殊处理
  
  if (typeof window === 'undefined') {
    // 服务端特殊处理
    try {
      return <NormalComponent />;
    } catch (error) {
      console.error('SSR error:', error);
      return <FallbackComponent />;
    }
  }
  
  return <NormalComponent />;
}

// 4. 错误边界自身的错误
class SelfErrorBoundary extends React.Component {
  state = { hasError: false };
  
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  
  componentDidCatch(error, errorInfo) {
    // 如果这里抛出错误，会导致无限循环
    try {
      this.reportError(error, errorInfo);
    } catch (reportError) {
      // 静默处理上报错误，避免无限循环
      console.error('Failed to report error:', reportError);
    }
  }
  
  reportError(error, errorInfo) {
    // 可能抛出错误的上报逻辑
    throw new Error('Report failed');
  }
  
  render() {
    if (this.state.hasError) {
      // 确保fallback UI不会抛出错误
      return <SimpleFallbackUI />;
    }
    
    return this.props.children;
  }
}

function SimpleFallbackUI() {
  // 简单的fallback UI，避免复杂逻辑
  return (
    <div style={{ padding: '20px', textAlign: 'center' }}>
      <h2>出现了错误</h2>
      <p>请刷新页面重试</p>
    </div>
  );
}
```

## 13. 常考算法题 ⭐⭐⭐

### 13.1 手写 useState

#### 基础版本
```javascript
let state = [];
let setters = [];
let firstRun = true;
let cursor = 0;

function createSetter(cursor) {
  return function setterWithCursor(newVal) {
    state[cursor] = newVal;
    renderWithHooks();
  };
}

function useState(initVal) {
  if (firstRun) {
    state.push(initVal);
    setters.push(createSetter(cursor));
    firstRun = false;
  }
  
  const setter = setters[cursor];
  const value = state[cursor];
  
  cursor++;
  return [value, setter];
}

function renderWithHooks() {
  cursor = 0;
  // 重新渲染组件
}
```

#### 完整版本（支持函数式更新）
```javascript
class ReactHooks {
  constructor() {
    this.hooks = [];
    this.currentHookIndex = 0;
    this.isFirstRender = true;
  }

  useState(initialState) {
    const hookIndex = this.currentHookIndex;
    
    // 初始化hook
    if (this.isFirstRender) {
      const hook = {
        state: typeof initialState === 'function' ? initialState() : initialState,
        queue: []
      };
      this.hooks[hookIndex] = hook;
    }
    
    const hook = this.hooks[hookIndex];
    
    // 处理队列中的更新
    while (hook.queue.length > 0) {
      const update = hook.queue.shift();
      hook.state = typeof update === 'function' 
        ? update(hook.state) 
        : update;
    }
    
    // 创建setState函数
    const setState = (newState) => {
      // 添加到更新队列
      hook.queue.push(newState);
      
      // 触发重新渲染
      this.scheduleUpdate();
    };
    
    this.currentHookIndex++;
    return [hook.state, setState];
  }
  
  scheduleUpdate() {
    // 模拟React的调度更新
    setTimeout(() => {
      this.currentHookIndex = 0;
      this.isFirstRender = false;
      this.render();
    }, 0);
  }
  
  render() {
    // 重新执行组件函数
    console.log('Component re-rendered');
  }
  
  resetHooks() {
    this.currentHookIndex = 0;
  }
}
```

### 13.2 手写 useEffect

#### 基础版本
```javascript
let deps = [];
let hasNoDeps = true;

function useEffect(callback, depArray) {
  const hasChangedDeps = deps
    ? !depArray.every((el, i) => el === deps[i])
    : true;
  
  if (hasChangedDeps || hasNoDeps) {
    callback();
    deps = depArray;
    hasNoDeps = false;
  }
}
```

#### 完整版本（支持清理函数）
```javascript
class EffectHook {
  constructor() {
    this.effects = [];
    this.currentEffectIndex = 0;
    this.isFirstRender = true;
  }

  useEffect(callback, deps) {
    const effectIndex = this.currentEffectIndex;
    
    if (this.isFirstRender) {
      // 首次渲染，创建effect
      const effect = {
        callback,
        deps,
        cleanup: null
      };
      this.effects[effectIndex] = effect;
      
      // 执行effect
      this.runEffect(effect);
    } else {
      // 后续渲染，检查依赖是否变化
      const prevEffect = this.effects[effectIndex];
      const hasChangedDeps = this.hasDepChanged(prevEffect.deps, deps);
      
      if (hasChangedDeps) {
        // 先执行清理函数
        if (prevEffect.cleanup) {
          prevEffect.cleanup();
        }
        
        // 更新effect
        prevEffect.callback = callback;
        prevEffect.deps = deps;
        
        // 执行新的effect
        this.runEffect(prevEffect);
      }
    }
    
    this.currentEffectIndex++;
  }
  
  runEffect(effect) {
    const cleanup = effect.callback();
    if (typeof cleanup === 'function') {
      effect.cleanup = cleanup;
    }
  }
  
  hasDepChanged(prevDeps, nextDeps) {
    // 如果没有依赖数组，每次都执行
    if (!nextDeps) return true;
    
    // 如果之前没有依赖，现在有了，说明变化了
    if (!prevDeps) return true;
    
    // 长度不同，说明变化了
    if (prevDeps.length !== nextDeps.length) return true;
    
    // 逐个比较依赖
    return prevDeps.some((dep, index) => 
      !Object.is(dep, nextDeps[index])
    );
  }
  
  cleanup() {
    // 组件卸载时执行所有清理函数
    this.effects.forEach(effect => {
      if (effect.cleanup) {
        effect.cleanup();
      }
    });
  }
  
  resetEffects() {
    this.currentEffectIndex = 0;
  }
}
```

### 13.3 手写 useReducer

```javascript
function useReducer(reducer, initialState, init) {
  // 如果提供了init函数，使用它来初始化state
  const [state, setState] = useState(
    init ? init(initialState) : initialState
  );
  
  const dispatch = useCallback((action) => {
    setState(prevState => reducer(prevState, action));
  }, [reducer]);
  
  return [state, dispatch];
}

// 更完整的实现
class ReducerHook {
  constructor() {
    this.reducers = [];
    this.currentReducerIndex = 0;
  }

  useReducer(reducer, initialState, init) {
    const reducerIndex = this.currentReducerIndex;
    
    if (!this.reducers[reducerIndex]) {
      // 初始化reducer hook
      const initialValue = init ? init(initialState) : initialState;
      
      this.reducers[reducerIndex] = {
        state: initialValue,
        queue: []
      };
    }
    
    const hook = this.reducers[reducerIndex];
    
    // 处理队列中的action
    while (hook.queue.length > 0) {
      const action = hook.queue.shift();
      hook.state = reducer(hook.state, action);
    }
    
    // 创建dispatch函数
    const dispatch = (action) => {
      hook.queue.push(action);
      this.scheduleUpdate();
    };
    
    this.currentReducerIndex++;
    return [hook.state, dispatch];
  }
  
  scheduleUpdate() {
    setTimeout(() => {
      this.currentReducerIndex = 0;
      this.render();
    }, 0);
  }
  
  render() {
    console.log('Component re-rendered with useReducer');
  }
}
```

### 13.4 手写 useMemo

```javascript
class MemoHook {
  constructor() {
    this.memos = [];
    this.currentMemoIndex = 0;
  }

  useMemo(factory, deps) {
    const memoIndex = this.currentMemoIndex;
    
    if (!this.memos[memoIndex]) {
      // 首次计算
      const value = factory();
      this.memos[memoIndex] = {
        value,
        deps
      };
    } else {
      // 检查依赖是否变化
      const memo = this.memos[memoIndex];
      const hasChangedDeps = this.hasDepChanged(memo.deps, deps);
      
      if (hasChangedDeps) {
        // 重新计算
        memo.value = factory();
        memo.deps = deps;
      }
    }
    
    this.currentMemoIndex++;
    return this.memos[memoIndex].value;
  }
  
  hasDepChanged(prevDeps, nextDeps) {
    if (!prevDeps || !nextDeps) return true;
    if (prevDeps.length !== nextDeps.length) return true;
    
    return prevDeps.some((dep, index) => 
      !Object.is(dep, nextDeps[index])
    );
  }
  
  resetMemos() {
    this.currentMemoIndex = 0;
  }
}
```

### 13.5 手写 useCallback

```javascript
class CallbackHook {
  constructor() {
    this.callbacks = [];
    this.currentCallbackIndex = 0;
  }

  useCallback(callback, deps) {
    const callbackIndex = this.currentCallbackIndex;
    
    if (!this.callbacks[callbackIndex]) {
      // 首次创建
      this.callbacks[callbackIndex] = {
        callback,
        deps
      };
    } else {
      // 检查依赖是否变化
      const hook = this.callbacks[callbackIndex];
      const hasChangedDeps = this.hasDepChanged(hook.deps, deps);
      
      if (hasChangedDeps) {
        // 更新回调函数
        hook.callback = callback;
        hook.deps = deps;
      }
    }
    
    this.currentCallbackIndex++;
    return this.callbacks[callbackIndex].callback;
  }
  
  hasDepChanged(prevDeps, nextDeps) {
    if (!prevDeps || !nextDeps) return true;
    if (prevDeps.length !== nextDeps.length) return true;
    
    return prevDeps.some((dep, index) => 
      !Object.is(dep, nextDeps[index])
    );
  }
  
  resetCallbacks() {
    this.currentCallbackIndex = 0;
  }
}
```

### 13.6 手写 useRef

```javascript
class RefHook {
  constructor() {
    this.refs = [];
    this.currentRefIndex = 0;
  }

  useRef(initialValue) {
    const refIndex = this.currentRefIndex;
    
    if (!this.refs[refIndex]) {
      // 创建ref对象
      this.refs[refIndex] = {
        current: initialValue
      };
    }
    
    this.currentRefIndex++;
    return this.refs[refIndex];
  }
  
  resetRefs() {
    this.currentRefIndex = 0;
  }
}
```

### 13.7 实现简单的 React 调度器

```javascript
class SimpleScheduler {
  constructor() {
    this.taskQueue = [];
    this.isRunning = false;
    this.currentTask = null;
    this.frameDeadline = 0;
  }
  
  // 调度任务
  scheduleCallback(priority, callback) {
    const currentTime = performance.now();
    const timeout = this.getTimeoutByPriority(priority);
    const expirationTime = currentTime + timeout;
    
    const task = {
      id: this.generateId(),
      callback,
      priority,
      expirationTime,
      startTime: currentTime
    };
    
    // 插入任务队列（按优先级排序）
    this.insertTask(task);
    
    // 开始调度
    if (!this.isRunning) {
      this.requestHostCallback();
    }
    
    return task;
  }
  
  // 取消任务
  cancelCallback(task) {
    task.callback = null;
  }
  
  // 插入任务到队列
  insertTask(task) {
    let index = 0;
    while (
      index < this.taskQueue.length &&
      this.taskQueue[index].expirationTime <= task.expirationTime
    ) {
      index++;
    }
    this.taskQueue.splice(index, 0, task);
  }
  
  // 获取优先级对应的超时时间
  getTimeoutByPriority(priority) {
    switch (priority) {
      case 'immediate':
        return -1; // 立即执行
      case 'user-blocking':
        return 250;
      case 'normal':
        return 5000;
      case 'low':
        return 10000;
      case 'idle':
        return 1073741823; // 最大值
      default:
        return 5000;
    }
  }
  
  // 请求主机回调
  requestHostCallback() {
    if (!this.isRunning) {
      this.isRunning = true;
      this.schedulePerformWorkUntilDeadline();
    }
  }
  
  // 调度工作直到截止时间
  schedulePerformWorkUntilDeadline() {
    // 使用MessageChannel实现异步调度
    const channel = new MessageChannel();
    const port1 = channel.port1;
    const port2 = channel.port2;
    
    port1.onmessage = () => {
      this.performWorkUntilDeadline();
    };
    
    port2.postMessage(null);
  }
  
  // 执行工作直到截止时间
  performWorkUntilDeadline() {
    const currentTime = performance.now();
    this.frameDeadline = currentTime + 5; // 5ms时间片
    
    let hasMoreWork = true;
    
    try {
      hasMoreWork = this.flushWork(currentTime);
    } catch (error) {
      // 如果有错误，继续调度剩余任务
      hasMoreWork = true;
      throw error;
    } finally {
      if (hasMoreWork) {
        // 还有更多工作，继续调度
        this.schedulePerformWorkUntilDeadline();
      } else {
        this.isRunning = false;
      }
    }
  }
  
  // 刷新工作
  flushWork(initialTime) {
    this.isRunning = true;
    
    try {
      return this.workLoop(initialTime);
    } finally {
      this.currentTask = null;
    }
  }
  
  // 工作循环
  workLoop(initialTime) {
    let currentTime = initialTime;
    this.advanceTimers(currentTime);
    
    this.currentTask = this.peek();
    
    while (this.currentTask !== null) {
      if (
        this.currentTask.expirationTime > currentTime &&
        this.shouldYieldToHost()
      ) {
        // 时间片用完，让出控制权
        break;
      }
      
      const callback = this.currentTask.callback;
      if (typeof callback === 'function') {
        this.currentTask.callback = null;
        
        const didUserCallbackTimeout = 
          this.currentTask.expirationTime <= currentTime;
        
        const continuationCallback = callback(didUserCallbackTimeout);
        
        currentTime = performance.now();
        
        if (typeof continuationCallback === 'function') {
          // 任务返回了继续函数，更新任务
          this.currentTask.callback = continuationCallback;
        } else {
          // 任务完成，从队列中移除
          if (this.currentTask === this.peek()) {
            this.pop();
          }
        }
        
        this.advanceTimers(currentTime);
      } else {
        this.pop();
      }
      
      this.currentTask = this.peek();
    }
    
    // 返回是否还有更多工作
    return this.currentTask !== null;
  }
  
  // 检查是否应该让出控制权
  shouldYieldToHost() {
    return performance.now() >= this.frameDeadline;
  }
  
  // 推进定时器
  advanceTimers(currentTime) {
    // 这里可以处理延迟任务
  }
  
  // 获取队列顶部任务
  peek() {
    return this.taskQueue.length > 0 ? this.taskQueue[0] : null;
  }
  
  // 移除队列顶部任务
  pop() {
    return this.taskQueue.shift();
  }
  
  // 生成任务ID
  generateId() {
    return Math.random().toString(36).substr(2, 9);
  }
}
```

### 13.8 实现简单的 Virtual DOM 和 Diff 算法

```javascript
// Virtual DOM节点
class VNode {
  constructor(type, props = {}, children = []) {
    this.type = type;
    this.props = props;
    this.children = Array.isArray(children) ? children : [children];
    this.key = props.key || null;
  }
}

// 创建虚拟节点的辅助函数
function createElement(type, props, ...children) {
  return new VNode(type, props, children.flat());
}

// 简单的Diff算法实现
class SimpleDiff {
  // 比较两个虚拟DOM树
  diff(oldVNode, newVNode) {
    const patches = [];
    this.walk(oldVNode, newVNode, 0, patches);
    return patches;
  }
  
  walk(oldNode, newNode, index, patches) {
    const currentPatch = [];
    
    if (newNode === null) {
      // 节点被删除
      currentPatch.push({ type: 'REMOVE', index });
    } else if (typeof oldNode === 'string' && typeof newNode === 'string') {
      // 文本节点
      if (oldNode !== newNode) {
        currentPatch.push({ type: 'TEXT', text: newNode, index });
      }
    } else if (oldNode.type === newNode.type) {
      // 同类型节点，比较属性
      const propsPatches = this.diffProps(oldNode.props, newNode.props);
      if (Object.keys(propsPatches).length > 0) {
        currentPatch.push({ type: 'PROPS', props: propsPatches, index });
      }
      
      // 比较子节点
      this.diffChildren(oldNode.children, newNode.children, index, patches);
    } else {
      // 不同类型节点，替换
      currentPatch.push({ type: 'REPLACE', node: newNode, index });
    }
    
    if (currentPatch.length > 0) {
      patches[index] = currentPatch;
    }
  }
  
  // 比较属性
  diffProps(oldProps, newProps) {
    const patches = {};
    
    // 检查属性变化和新增
    for (const key in newProps) {
      if (oldProps[key] !== newProps[key]) {
        patches[key] = newProps[key];
      }
    }
    
    // 检查删除的属性
    for (const key in oldProps) {
      if (!(key in newProps)) {
        patches[key] = null;
      }
    }
    
    return patches;
  }
  
  // 比较子节点
  diffChildren(oldChildren, newChildren, index, patches) {
    let leftNode = null;
    let currentNodeIndex = index;
    
    const maxLength = Math.max(oldChildren.length, newChildren.length);
    
    for (let i = 0; i < maxLength; i++) {
      const oldChild = oldChildren[i];
      const newChild = newChildren[i];
      
      currentNodeIndex = index + i + 1;
      
      this.walk(oldChild, newChild, currentNodeIndex, patches);
      
      if (leftNode && leftNode.children) {
        currentNodeIndex += leftNode.children.length;
      }
      
      leftNode = oldChild;
    }
  }
}

// 渲染虚拟DOM到真实DOM
class Renderer {
  render(vnode, container) {
    const dom = this.createDOM(vnode);
    container.appendChild(dom);
    return dom;
  }
  
  createDOM(vnode) {
    if (typeof vnode === 'string' || typeof vnode === 'number') {
      return document.createTextNode(vnode);
    }
    
    const dom = document.createElement(vnode.type);
    
    // 设置属性
    if (vnode.props) {
      this.setProps(dom, vnode.props);
    }
    
    // 渲染子节点
    if (vnode.children) {
      vnode.children.forEach(child => {
        if (child) {
          dom.appendChild(this.createDOM(child));
        }
      });
    }
    
    return dom;
  }
  
  setProps(dom, props) {
    for (const key in props) {
      if (key === 'key') continue;
      
      if (key.startsWith('on')) {
        // 事件处理
        const eventType = key.slice(2).toLowerCase();
        dom.addEventListener(eventType, props[key]);
      } else if (key === 'style') {
        // 样式处理
        if (typeof props[key] === 'object') {
          Object.assign(dom.style, props[key]);
        } else {
          dom.style.cssText = props[key];
        }
      } else if (key === 'className') {
        dom.className = props[key];
      } else {
        dom.setAttribute(key, props[key]);
      }
    }
  }
  
  // 应用补丁
  patch(dom, patches) {
    const walker = { index: 0 };
    this.dfsWalk(dom, walker, patches);
  }
  
  dfsWalk(node, walker, patches) {
    const currentPatches = patches[walker.index];
    
    const len = node.childNodes ? node.childNodes.length : 0;
    for (let i = 0; i < len; i++) {
      walker.index++;
      this.dfsWalk(node.childNodes[i], walker, patches);
    }
    
    if (currentPatches) {
      this.applyPatches(node, currentPatches);
    }
  }
  
  applyPatches(node, currentPatches) {
    currentPatches.forEach(patch => {
      switch (patch.type) {
        case 'REPLACE':
          const newNode = this.createDOM(patch.node);
          node.parentNode.replaceChild(newNode, node);
          break;
        case 'REMOVE':
          node.parentNode.removeChild(node);
          break;
        case 'TEXT':
          node.textContent = patch.text;
          break;
        case 'PROPS':
          this.setProps(node, patch.props);
          break;
      }
    });
  }
}
```

## 14. 重点总结

### 必须掌握的概念
1. **Virtual DOM 和 Diff 算法**
2. **Fiber 架构和工作原理**
3. **Hooks 原理和使用规则**
4. **生命周期方法**
5. **事件系统和合成事件**
6. **性能优化策略**
7. **setState 的异步更新机制**

### 常见题
1. React 和 Vue 的区别？
2. 为什么需要 Virtual DOM？
3. Fiber 解决了什么问题？
4. Hooks 的实现原理？
5. 如何优化 React 应用性能？
6. setState 是同步还是异步的？
7. React 事件系统的特点？
8. 如何避免组件不必要的重新渲染？

### 学习建议
1. **理论结合实践**: 理解原理的同时多写代码
2. **源码阅读**: 阅读 React 源码加深理解
3. **性能调优**: 学会使用 React DevTools 分析性能
4. **跟进新特性**: 关注 React 的最新发展
5. **项目实战**: 在实际项目中应用所学知识

## 参考资源

- [React 官方文档](https://reactjs.org/)
- [React 源码](https://github.com/facebook/react)
- [React Fiber 架构](https://github.com/acdlite/react-fiber-architecture)
- [React 技术揭秘](https://react.iamkasong.com/)
- [图解 React 原理系列](https://7kms.github.io/react-illustration-series/)