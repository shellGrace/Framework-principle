# 小程序框架原理（中优先级 ⭐⭐⭐⭐）

## 1. 小程序架构概述

### 1.1 双线程架构
```
渲染层（WebView）          逻辑层（JSCore）
     ↓                        ↓
   WXML/WXSS               JavaScript
     ↓                        ↓
   页面渲染    ←→ Native ←→   业务逻辑
                 (微信客户端)
```

### 1.2 架构设计原因
- **安全性**：防止恶意代码直接操作 DOM
- **性能**：避免 JS 执行阻塞 UI 渲染
- **管控**：便于平台方进行代码审核和限制
- **稳定性**：隔离业务逻辑和渲染逻辑

### 1.3 通信机制
```javascript
// 逻辑层 → 渲染层
this.setData({
  message: 'Hello World'
});

// 渲染层 → 逻辑层
// WXML 中的事件绑定
<button bindtap="handleTap">点击</button>

// 通信流程
逻辑层 setData → Native → 渲染层更新
渲染层事件 → Native → 逻辑层处理
```

## 2. 渲染层原理

### 2.1 WXML 编译
```xml
<!-- 源码 WXML -->
<view class="container">
  <text>{{message}}</text>
  <button bindtap="handleTap">{{buttonText}}</button>
</view>

<!-- 编译后的虚拟 DOM 结构 -->
{
  "tag": "view",
  "attr": { "class": "container" },
  "children": [
    {
      "tag": "text",
      "children": ["{{message}}"]
    },
    {
      "tag": "button",
      "attr": { "bindtap": "handleTap" },
      "children": ["{{buttonText}}"]
    }
  ]
}
```

### 2.2 数据绑定机制
```javascript
// 简化的数据绑定实现
class DataBinding {
  constructor() {
    this.data = {};
    this.watchers = new Map();
  }
  
  setData(newData) {
    // 1. 数据 diff
    const changes = this.diff(this.data, newData);
    
    // 2. 更新数据
    Object.assign(this.data, newData);
    
    // 3. 通知渲染层更新
    this.notifyRender(changes);
  }
  
  diff(oldData, newData) {
    const changes = {};
    
    Object.keys(newData).forEach(key => {
      if (oldData[key] !== newData[key]) {
        changes[key] = newData[key];
      }
    });
    
    return changes;
  }
  
  notifyRender(changes) {
    // 发送到渲染层
    wx.sendToRender({
      type: 'dataChange',
      data: changes
    });
  }
}
```

### 2.3 WXSS 样式处理
```css
/* 源码 WXSS */
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* 编译后添加作用域 */
.container[data-v-123abc] {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* 尺寸单位转换 */
.box {
  width: 750rpx; /* 转换为 100vw */
  height: 200rpx; /* 转换为 26.67vw */
}
```

## 3. 逻辑层原理

### 3.1 JavaScript 引擎
```javascript
// 不同平台的 JS 引擎
const jsEngines = {
  iOS: 'JavaScriptCore',
  Android: 'V8',
  DevTools: 'Chrome V8'
};

// 全局对象注入
global.wx = {
  // 基础 API
  request: nativeRequest,
  showToast: nativeShowToast,
  
  // 界面 API
  navigateTo: nativeNavigateTo,
  setNavigationBarTitle: nativeSetTitle,
  
  // 设备 API
  getSystemInfo: nativeGetSystemInfo,
  getLocation: nativeGetLocation
};
```

### 3.2 页面生命周期
```javascript
// 页面生命周期实现
class Page {
  constructor(options) {
    this.data = options.data || {};
    this.options = options;
    
    // 绑定生命周期方法
    this.onLoad = options.onLoad;
    this.onShow = options.onShow;
    this.onReady = options.onReady;
    this.onHide = options.onHide;
    this.onUnload = options.onUnload;
  }
  
  // 页面加载
  _onLoad(query) {
    this.onLoad && this.onLoad(query);
  }
  
  // 页面显示
  _onShow() {
    this.onShow && this.onShow();
  }
  
  // 页面初次渲染完成
  _onReady() {
    this.onReady && this.onReady();
  }
  
  // 数据更新
  setData(data, callback) {
    // 数据合并
    Object.assign(this.data, data);
    
    // 发送到渲染层
    this._sendDataToRender(data);
    
    // 执行回调
    callback && callback();
  }
  
  _sendDataToRender(data) {
    wx.sendToRender({
      type: 'setData',
      data: data,
      pageId: this.pageId
    });
  }
}

// 页面注册
function Page(options) {
  const page = new Page(options);
  getCurrentPages().push(page);
  return page;
}
```

### 3.3 组件系统
```javascript
// 组件定义
Component({
  properties: {
    title: {
      type: String,
      value: '默认标题'
    },
    count: {
      type: Number,
      value: 0,
      observer: function(newVal, oldVal) {
        console.log('count changed:', oldVal, '->', newVal);
      }
    }
  },
  
  data: {
    internal: 'internal data'
  },
  
  methods: {
    increment() {
      this.setData({
        count: this.data.count + 1
      });
      
      // 触发自定义事件
      this.triggerEvent('countchange', {
        count: this.data.count + 1
      });
    }
  },
  
  lifetimes: {
    attached() {
      // 组件实例进入页面节点树时执行
    },
    detached() {
      // 组件实例被从页面节点树移除时执行
    }
  }
});
```

## 4. 路由系统

### 4.1 路由栈管理
```javascript
class NavigationManager {
  constructor() {
    this.pageStack = [];
    this.maxStackSize = 10;
  }
  
  navigateTo(options) {
    if (this.pageStack.length >= this.maxStackSize) {
      throw new Error('页面栈已满');
    }
    
    const newPage = this.createPage(options.url);
    this.pageStack.push(newPage);
    this.switchToPage(newPage);
  }
  
  redirectTo(options) {
    // 替换当前页面
    const currentPage = this.getCurrentPage();
    this.destroyPage(currentPage);
    
    const newPage = this.createPage(options.url);
    this.pageStack[this.pageStack.length - 1] = newPage;
    this.switchToPage(newPage);
  }
  
  navigateBack(delta = 1) {
    if (this.pageStack.length <= delta) {
      throw new Error('无法返回');
    }
    
    // 销毁要移除的页面
    for (let i = 0; i < delta; i++) {
      const page = this.pageStack.pop();
      this.destroyPage(page);
    }
    
    // 显示目标页面
    const targetPage = this.getCurrentPage();
    this.switchToPage(targetPage);
  }
  
  reLaunch(options) {
    // 清空页面栈
    this.pageStack.forEach(page => this.destroyPage(page));
    this.pageStack = [];
    
    // 创建新页面
    const newPage = this.createPage(options.url);
    this.pageStack.push(newPage);
    this.switchToPage(newPage);
  }
  
  getCurrentPage() {
    return this.pageStack[this.pageStack.length - 1];
  }
}
```

### 4.2 页面参数传递
```javascript
// 页面跳转传参
wx.navigateTo({
  url: '/pages/detail/detail?id=123&type=product'
});

// 目标页面接收参数
Page({
  onLoad(options) {
    console.log(options.id);   // '123'
    console.log(options.type); // 'product'
  }
});

// 页面间通信
// 方式1：通过 getCurrentPages 获取页面实例
const pages = getCurrentPages();
const prevPage = pages[pages.length - 2];
prevPage.setData({
  result: 'data from current page'
});

// 方式2：通过事件总线
const eventBus = getApp().globalData.eventBus;
eventBus.emit('dataUpdate', { data: 'new data' });
```

## 5. 性能优化

### 5.1 setData 优化
```javascript
// ❌ 频繁调用 setData
for (let i = 0; i < 100; i++) {
  this.setData({
    [`list[${i}]`]: newItem
  });
}

// ✅ 批量更新
const updates = {};
for (let i = 0; i < 100; i++) {
  updates[`list[${i}]`] = newItem;
}
this.setData(updates);

// ✅ 只更新变化的数据
this.setData({
  'user.name': newName,  // 只更新 name 字段
  'list[0].status': 'active'  // 只更新特定数组项
});

// ❌ 传递大量数据
this.setData({
  largeArray: new Array(10000).fill(0)
});

// ✅ 分页加载
this.setData({
  [`list[${this.data.list.length}]`]: newItem
});
```

### 5.2 渲染优化
```xml
<!-- 条件渲染优化 -->
<!-- ❌ 使用 hidden -->
<view hidden="{{!showContent}}">大量内容</view>

<!-- ✅ 使用 wx:if -->
<view wx:if="{{showContent}}">大量内容</view>

<!-- 列表渲染优化 -->
<view wx:for="{{list}}" wx:key="id">
  {{item.name}}
</view>

<!-- 虚拟列表实现 -->
<scroll-view 
  scroll-y 
  style="height: 400px"
  bindscroll="onScroll"
>
  <view style="height: {{topHeight}}px"></view>
  <view wx:for="{{visibleItems}}" wx:key="id">
    {{item.name}}
  </view>
  <view style="height: {{bottomHeight}}px"></view>
</scroll-view>
```

### 5.3 内存管理
```javascript
Page({
  onLoad() {
    // 定时器管理
    this.timer = setInterval(() => {
      // 定时任务
    }, 1000);
    
    // 事件监听
    this.onNetworkChange = (res) => {
      console.log('网络状态变化', res);
    };
    wx.onNetworkStatusChange(this.onNetworkChange);
  },
  
  onUnload() {
    // 清理定时器
    if (this.timer) {
      clearInterval(this.timer);
    }
    
    // 移除事件监听
    wx.offNetworkStatusChange(this.onNetworkChange);
    
    // 清理大对象
    this.largeData = null;
  }
});
```

## 6. 跨平台适配

### 6.1 条件编译
```javascript
// #ifdef MP-WEIXIN
// 微信小程序特有代码
wx.showToast({
  title: '微信小程序'
});
// #endif

// #ifdef MP-ALIPAY
// 支付宝小程序特有代码
my.showToast({
  content: '支付宝小程序'
});
// #endif

// #ifdef H5
// H5 特有代码
alert('H5 页面');
// #endif
```

### 6.2 API 统一封装
```javascript
// 统一的 API 封装
class UnifiedAPI {
  static showToast(options) {
    // #ifdef MP-WEIXIN
    return wx.showToast(options);
    // #endif
    
    // #ifdef MP-ALIPAY
    return my.showToast({
      content: options.title,
      duration: options.duration
    });
    // #endif
    
    // #ifdef H5
    alert(options.title);
    // #endif
  }
  
  static request(options) {
    return new Promise((resolve, reject) => {
      // #ifdef MP-WEIXIN
      wx.request({
        ...options,
        success: resolve,
        fail: reject
      });
      // #endif
      
      // #ifdef MP-ALIPAY
      my.request({
        ...options,
        success: resolve,
        fail: reject
      });
      // #endif
      
      // #ifdef H5
      fetch(options.url, {
        method: options.method,
        body: JSON.stringify(options.data)
      })
      .then(response => response.json())
      .then(resolve)
      .catch(reject);
      // #endif
    });
  }
}
```

## 7. 小程序框架对比

### 7.1 原生 vs 框架
```javascript
// 原生小程序
Page({
  data: {
    count: 0
  },
  increment() {
    this.setData({
      count: this.data.count + 1
    });
  }
});

// Taro (React 语法)
import { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <View>
      <Text>{count}</Text>
      <Button onClick={() => setCount(count + 1)}>+</Button>
    </View>
  );
}

// uni-app (Vue 语法)
<template>
  <view>
    <text>{{count}}</text>
    <button @click="increment">+</button>
  </view>
</template>

<script>
export default {
  data() {
    return {
      count: 0
    }
  },
  methods: {
    increment() {
      this.count++;
    }
  }
}
</script>
```

### 7.2 框架特点对比
```
Taro：
- React/Vue 语法
- 编译时转换
- 多端统一
- 社区活跃

uni-app：
- Vue 语法
- 运行时适配
- 平台覆盖广
- DCloud 生态

Remax：
- 真正的 React
- 运行时方案
- 更接近 Web 开发
- 性能较好

Mpvue：
- Vue 语法
- 编译时转换
- 已停止维护
- 历史项目较多
```

## 8. 调试和测试

### 8.1 调试工具
```javascript
// 开发者工具调试
console.log('调试信息');
console.error('错误信息');
console.warn('警告信息');

// 性能监控
const start = Date.now();
// 执行代码
const end = Date.now();
console.log('执行时间:', end - start);

// 网络请求监控
wx.request({
  url: 'https://api.example.com/data',
  success(res) {
    console.log('请求成功:', res);
  },
  fail(err) {
    console.error('请求失败:', err);
  }
});
```

### 8.2 单元测试
```javascript
// 使用 Jest 进行单元测试
describe('工具函数测试', () => {
  test('格式化日期', () => {
    const result = formatDate(new Date('2023-01-01'));
    expect(result).toBe('2023-01-01');
  });
  
  test('数据验证', () => {
    const isValid = validateForm({
      name: 'test',
      email: 'test@example.com'
    });
    expect(isValid).toBe(true);
  });
});

// 页面逻辑测试
describe('页面逻辑测试', () => {
  test('数据更新', () => {
    const page = new MockPage();
    page.setData({ count: 1 });
    expect(page.data.count).toBe(1);
  });
});
```

## 9. 面试重点

### 9.1 架构理解
1. **双线程架构**：为什么采用双线程设计
2. **通信机制**：逻辑层和渲染层如何通信
3. **生命周期**：页面和组件的生命周期
4. **路由管理**：页面栈的管理机制
5. **数据绑定**：setData 的实现原理

### 9.2 性能优化
1. **setData 优化**：减少调用频次和数据量
2. **渲染优化**：条件渲染和列表渲染
3. **内存管理**：避免内存泄漏
4. **包体积优化**：代码分包和资源优化
5. **启动性能**：首屏加载优化

### 9.3 实际应用
- 电商小程序开发
- 工具类小程序
- 游戏小程序
- 企业内部应用
- 跨平台解决方案

---

**学习建议**：
1. 理解双线程架构的设计思想
2. 掌握性能优化的最佳实践
3. 熟悉跨平台开发框架
4. 关注小程序生态发展
5. 实践复杂业务场景开发