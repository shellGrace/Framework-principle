# 微前端原理详解

## 1. 微前端概述

### 1.1 什么是微前端
- **定义**：将前端应用分解为多个独立的、可部署的微应用
- **理念**：借鉴微服务架构思想，应用于前端领域
- **目标**：技术栈无关、独立开发部署、团队自治

### 1.2 微前端架构
```
主应用（Shell App）
├── 微应用 A（React）
├── 微应用 B（Vue）
├── 微应用 C（Angular）
└── 共享依赖（Shared Dependencies）
```

### 1.3 核心特征
- **技术栈无关**：不同微应用可使用不同技术栈
- **独立开发**：团队可独立开发和测试
- **独立部署**：支持独立发布和回滚
- **运行时集成**：在浏览器中动态组合

## 2. 微前端实现方案

### 2.1 iframe 方案
```html
<!-- 最简单的微前端实现 -->
<div class="micro-app-container">
  <iframe 
    src="https://micro-app-a.example.com"
    width="100%"
    height="500px"
    frameborder="0">
  </iframe>
</div>

<script>
// iframe 通信
function sendMessageToMicroApp(data) {
  const iframe = document.querySelector('iframe');
  iframe.contentWindow.postMessage(data, '*');
}

// 监听微应用消息
window.addEventListener('message', (event) => {
  if (event.origin === 'https://micro-app-a.example.com') {
    console.log('Message from micro app:', event.data);
  }
});
</script>
```

**优点**：
- 完全隔离（样式、JS、全局变量）
- 实现简单
- 安全性好

**缺点**：
- 性能开销大
- 用户体验差（刷新、前进后退）
- 通信复杂
- 移动端兼容性问题

### 2.2 Single-SPA 方案
```javascript
// 主应用配置
import { registerApplication, start } from 'single-spa';

// 注册微应用
registerApplication({
  name: 'react-app',
  app: () => System.import('react-app'),
  activeWhen: '/react',
  customProps: {
    domElement: document.getElementById('react-container')
  }
});

registerApplication({
  name: 'vue-app',
  app: () => System.import('vue-app'),
  activeWhen: '/vue'
});

// 启动 single-spa
start();

// 微应用（React）
const reactLifecycles = {
  mount(props) {
    return Promise.resolve().then(() => {
      ReactDOM.render(
        <App />, 
        props.domElement || document.getElementById('root')
      );
    });
  },
  
  unmount(props) {
    return Promise.resolve().then(() => {
      ReactDOM.unmountComponentAtNode(
        props.domElement || document.getElementById('root')
      );
    });
  }
};

export const { mount, unmount } = reactLifecycles;
```

### 2.3 Module Federation 方案
```javascript
// webpack.config.js (主应用)
const ModuleFederationPlugin = require('@module-federation/webpack');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'shell',
      remotes: {
        mfReact: 'mfReact@http://localhost:3001/remoteEntry.js',
        mfVue: 'mfVue@http://localhost:3002/remoteEntry.js'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// webpack.config.js (微应用)
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'mfReact',
      filename: 'remoteEntry.js',
      exposes: {
        './App': './src/App'
      },
      shared: {
        react: { singleton: true },
        'react-dom': { singleton: true }
      }
    })
  ]
};

// 主应用中使用
import React, { Suspense } from 'react';

const RemoteApp = React.lazy(() => import('mfReact/App'));

function App() {
  return (
    <div>
      <h1>Shell App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <RemoteApp />
      </Suspense>
    </div>
  );
}
```

### 2.4 qiankun 方案
```javascript
// 主应用
import { registerMicroApps, start } from 'qiankun';

// 注册微应用
registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:3001',
    container: '#react-container',
    activeRule: '/react'
  },
  {
    name: 'vue-app',
    entry: '//localhost:3002',
    container: '#vue-container',
    activeRule: '/vue'
  }
]);

// 启动 qiankun
start();

// 微应用（React）
// src/public-path.js
if (window.__POWERED_BY_QIANKUN__) {
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}

// src/index.js
import './public-path';
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

function render(props) {
  const { container } = props;
  ReactDOM.render(
    <App />, 
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}

// 独立运行
if (!window.__POWERED_BY_QIANKUN__) {
  render({});
}

// 导出生命周期函数
export async function bootstrap() {
  console.log('react app bootstraped');
}

export async function mount(props) {
  console.log('props from main framework', props);
  render(props);
}

export async function unmount(props) {
  const { container } = props;
  ReactDOM.unmountComponentAtNode(
    container ? container.querySelector('#root') : document.querySelector('#root')
  );
}
```

## 3. 应用隔离机制

### 3.1 JavaScript 隔离
```javascript
// 快照沙箱（Snapshot Sandbox）
class SnapshotSandbox {
  constructor() {
    this.proxy = window;
    this.modifyPropsMap = {};
    this.active = false;
  }
  
  active() {
    this.windowSnapshot = {};
    
    // 记录当前 window 状态
    for (const prop in window) {
      if (window.hasOwnProperty(prop)) {
        this.windowSnapshot[prop] = window[prop];
      }
    }
    
    // 恢复之前的修改
    Object.keys(this.modifyPropsMap).forEach(p => {
      window[p] = this.modifyPropsMap[p];
    });
    
    this.active = true;
  }
  
  inactive() {
    this.modifyPropsMap = {};
    
    // 记录修改的属性
    for (const prop in window) {
      if (window.hasOwnProperty(prop)) {
        if (window[prop] !== this.windowSnapshot[prop]) {
          this.modifyPropsMap[prop] = window[prop];
          window[prop] = this.windowSnapshot[prop];
        }
      }
    }
    
    this.active = false;
  }
}

// Proxy 沙箱
class ProxySandbox {
  constructor() {
    const fakeWindow = {};
    
    this.proxy = new Proxy(fakeWindow, {
      get(target, prop) {
        // 优先从代理对象获取
        if (prop in target) {
          return target[prop];
        }
        
        // 从真实 window 获取
        const value = window[prop];
        
        // 绑定函数的 this 指向
        if (typeof value === 'function') {
          return value.bind(window);
        }
        
        return value;
      },
      
      set(target, prop, value) {
        // 设置到代理对象
        target[prop] = value;
        return true;
      },
      
      has(target, prop) {
        return prop in target || prop in window;
      }
    });
  }
}
```

### 3.2 CSS 隔离
```javascript
// CSS 作用域隔离
class StyleSandbox {
  constructor(appName) {
    this.appName = appName;
    this.styleNodes = [];
  }
  
  // 添加样式隔离
  addStyleScope(styleNode) {
    const css = styleNode.textContent;
    const scopedCSS = this.addScope(css, `[data-qiankun="${this.appName}"]`);
    styleNode.textContent = scopedCSS;
  }
  
  addScope(css, scope) {
    const ast = this.parseCSS(css);
    
    ast.rules.forEach(rule => {
      if (rule.type === 'rule') {
        rule.selectors = rule.selectors.map(selector => {
          // 为每个选择器添加作用域
          return `${scope} ${selector}`;
        });
      }
    });
    
    return this.stringifyCSS(ast);
  }
  
  // 动态样式处理
  patchDynamicStyle() {
    const originalCreateElement = document.createElement;
    const self = this;
    
    document.createElement = function(tagName) {
      const element = originalCreateElement.call(document, tagName);
      
      if (tagName === 'style') {
        const originalAppendChild = element.appendChild;
        element.appendChild = function(node) {
          self.addStyleScope(element);
          return originalAppendChild.call(element, node);
        };
      }
      
      return element;
    };
  }
}
```

### 3.3 DOM 隔离
```javascript
// DOM 查询隔离
class DOMSandbox {
  constructor(container) {
    this.container = container;
    this.patchDocument();
  }
  
  patchDocument() {
    const container = this.container;
    
    // 劫持 document.querySelector
    const originalQuerySelector = document.querySelector;
    document.querySelector = function(selector) {
      // 优先在容器内查找
      const element = container.querySelector(selector);
      if (element) {
        return element;
      }
      
      // 回退到全局查找
      return originalQuerySelector.call(document, selector);
    };
    
    // 劫持 document.getElementById
    const originalGetElementById = document.getElementById;
    document.getElementById = function(id) {
      const element = container.querySelector(`#${id}`);
      if (element) {
        return element;
      }
      
      return originalGetElementById.call(document, id);
    };
    
    // 劫持事件监听
    const originalAddEventListener = document.addEventListener;
    document.addEventListener = function(type, listener, options) {
      // 记录事件监听器，便于清理
      if (!container._eventListeners) {
        container._eventListeners = [];
      }
      
      container._eventListeners.push({ type, listener, options });
      
      return originalAddEventListener.call(document, type, listener, options);
    };
  }
  
  // 清理副作用
  cleanup() {
    // 移除事件监听器
    if (this.container._eventListeners) {
      this.container._eventListeners.forEach(({ type, listener, options }) => {
        document.removeEventListener(type, listener, options);
      });
    }
    
    // 恢复原始方法
    // ...
  }
}
```

## 4. 应用通信机制

### 4.1 Props 传递
```javascript
// 主应用向微应用传递数据
registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:3001',
    container: '#react-container',
    activeRule: '/react',
    props: {
      user: { id: 1, name: 'John' },
      theme: 'dark',
      onMessage: (data) => {
        console.log('Message from micro app:', data);
      }
    }
  }
]);

// 微应用接收数据
export async function mount(props) {
  const { user, theme, onMessage } = props;
  
  render({
    user,
    theme,
    onMessage
  });
}
```

### 4.2 事件总线
```javascript
// 全局事件总线
class EventBus {
  constructor() {
    this.events = {};
  }
  
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
  }
  
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => {
        callback(data);
      });
    }
  }
  
  once(event, callback) {
    const onceCallback = (data) => {
      callback(data);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }
}

// 全局注册
window.__MICRO_APP_EVENT_BUS__ = new EventBus();

// 微应用中使用
const eventBus = window.__MICRO_APP_EVENT_BUS__;

// 发送消息
eventBus.emit('user-login', { userId: 123 });

// 监听消息
eventBus.on('theme-change', (theme) => {
  console.log('Theme changed to:', theme);
});
```

### 4.3 共享状态
```javascript
// 使用 Redux 共享状态
class SharedStore {
  constructor() {
    this.store = Redux.createStore(this.reducer);
    this.subscribers = new Set();
  }
  
  reducer(state = {}, action) {
    switch (action.type) {
      case 'SET_USER':
        return { ...state, user: action.payload };
      case 'SET_THEME':
        return { ...state, theme: action.payload };
      default:
        return state;
    }
  }
  
  getState() {
    return this.store.getState();
  }
  
  dispatch(action) {
    this.store.dispatch(action);
    this.notifySubscribers();
  }
  
  subscribe(callback) {
    this.subscribers.add(callback);
    
    return () => {
      this.subscribers.delete(callback);
    };
  }
  
  notifySubscribers() {
    const state = this.getState();
    this.subscribers.forEach(callback => {
      callback(state);
    });
  }
}

// 全局共享
window.__SHARED_STORE__ = new SharedStore();

// 微应用中使用
const sharedStore = window.__SHARED_STORE__;

// 订阅状态变化
sharedStore.subscribe((state) => {
  console.log('Shared state changed:', state);
});

// 更新状态
sharedStore.dispatch({
  type: 'SET_USER',
  payload: { id: 1, name: 'John' }
});
```

## 5. 路由管理

### 5.1 主应用路由配置
```javascript
// 基于 React Router 的路由配置
import { BrowserRouter, Route, Switch } from 'react-router-dom';
import { registerMicroApps, start } from 'qiankun';

// 注册微应用
registerMicroApps([
  {
    name: 'react-app',
    entry: '//localhost:3001',
    container: '#micro-app-container',
    activeRule: '/react'
  },
  {
    name: 'vue-app',
    entry: '//localhost:3002',
    container: '#micro-app-container',
    activeRule: '/vue'
  }
]);

start();

function App() {
  return (
    <BrowserRouter>
      <div className="app">
        <nav>
          <Link to="/">Home</Link>
          <Link to="/react">React App</Link>
          <Link to="/vue">Vue App</Link>
        </nav>
        
        <Switch>
          <Route exact path="/" component={Home} />
          <Route path="/react" render={() => <div id="micro-app-container" />} />
          <Route path="/vue" render={() => <div id="micro-app-container" />} />
        </Switch>
      </div>
    </BrowserRouter>
  );
}
```

### 5.2 微应用路由配置
```javascript
// 微应用（React）路由配置
import { BrowserRouter, Route, Switch } from 'react-router-dom';

function App() {
  // 获取基础路径
  const basename = window.__POWERED_BY_QIANKUN__ ? '/react' : '/';
  
  return (
    <BrowserRouter basename={basename}>
      <Switch>
        <Route exact path="/" component={Home} />
        <Route path="/about" component={About} />
        <Route path="/products" component={Products} />
      </Switch>
    </BrowserRouter>
  );
}

// 微应用（Vue）路由配置
const router = new VueRouter({
  mode: 'history',
  base: window.__POWERED_BY_QIANKUN__ ? '/vue' : '/',
  routes: [
    { path: '/', component: Home },
    { path: '/about', component: About },
    { path: '/contact', component: Contact }
  ]
});
```

### 5.3 路由同步
```javascript
// 路由状态同步
class RouterSync {
  constructor() {
    this.currentRoute = window.location.pathname;
    this.listeners = new Set();
    this.init();
  }
  
  init() {
    // 监听路由变化
    window.addEventListener('popstate', this.handleRouteChange.bind(this));
    
    // 劫持 pushState 和 replaceState
    this.patchHistory();
  }
  
  patchHistory() {
    const originalPushState = history.pushState;
    const originalReplaceState = history.replaceState;
    
    history.pushState = (...args) => {
      originalPushState.apply(history, args);
      this.handleRouteChange();
    };
    
    history.replaceState = (...args) => {
      originalReplaceState.apply(history, args);
      this.handleRouteChange();
    };
  }
  
  handleRouteChange() {
    const newRoute = window.location.pathname;
    if (newRoute !== this.currentRoute) {
      this.currentRoute = newRoute;
      this.notifyListeners(newRoute);
    }
  }
  
  subscribe(callback) {
    this.listeners.add(callback);
    
    return () => {
      this.listeners.delete(callback);
    };
  }
  
  notifyListeners(route) {
    this.listeners.forEach(callback => {
      callback(route);
    });
  }
}

// 全局路由同步
window.__ROUTER_SYNC__ = new RouterSync();
```

## 6. 性能优化

### 6.1 资源预加载
```javascript
// 预加载微应用资源
class ResourcePreloader {
  constructor() {
    this.cache = new Map();
  }
  
  async preloadApp(entry) {
    if (this.cache.has(entry)) {
      return this.cache.get(entry);
    }
    
    try {
      // 预加载 HTML
      const html = await this.fetchHTML(entry);
      
      // 解析资源链接
      const { scripts, styles } = this.parseResources(html);
      
      // 预加载脚本和样式
      await Promise.all([
        ...scripts.map(src => this.preloadScript(src)),
        ...styles.map(href => this.preloadStyle(href))
      ]);
      
      const resources = { html, scripts, styles };
      this.cache.set(entry, resources);
      
      return resources;
    } catch (error) {
      console.error('Preload failed:', error);
      throw error;
    }
  }
  
  async fetchHTML(url) {
    const response = await fetch(url);
    return response.text();
  }
  
  parseResources(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    const scripts = Array.from(doc.querySelectorAll('script[src]'))
      .map(script => script.src);
    
    const styles = Array.from(doc.querySelectorAll('link[rel="stylesheet"]'))
      .map(link => link.href);
    
    return { scripts, styles };
  }
  
  preloadScript(src) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'script';
      link.href = src;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
  
  preloadStyle(href) {
    return new Promise((resolve, reject) => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'style';
      link.href = href;
      link.onload = resolve;
      link.onerror = reject;
      document.head.appendChild(link);
    });
  }
}
```

### 6.2 缓存策略
```javascript
// 微应用缓存管理
class AppCache {
  constructor() {
    this.appCache = new Map();
    this.maxCacheSize = 5;
  }
  
  set(name, app) {
    // LRU 缓存策略
    if (this.appCache.size >= this.maxCacheSize) {
      const firstKey = this.appCache.keys().next().value;
      this.appCache.delete(firstKey);
    }
    
    this.appCache.set(name, {
      ...app,
      cachedAt: Date.now()
    });
  }
  
  get(name) {
    const app = this.appCache.get(name);
    if (app) {
      // 更新访问时间
      this.appCache.delete(name);
      this.appCache.set(name, {
        ...app,
        accessedAt: Date.now()
      });
    }
    return app;
  }
  
  has(name) {
    return this.appCache.has(name);
  }
  
  clear() {
    this.appCache.clear();
  }
  
  // 清理过期缓存
  cleanup(maxAge = 30 * 60 * 1000) { // 30分钟
    const now = Date.now();
    
    for (const [name, app] of this.appCache.entries()) {
      if (now - app.cachedAt > maxAge) {
        this.appCache.delete(name);
      }
    }
  }
}
```

### 6.3 懒加载
```javascript
// 微应用懒加载
class LazyLoader {
  constructor() {
    this.observer = new IntersectionObserver(
      this.handleIntersection.bind(this),
      { threshold: 0.1 }
    );
  }
  
  observe(element, appConfig) {
    element._appConfig = appConfig;
    this.observer.observe(element);
  }
  
  handleIntersection(entries) {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        const { target } = entry;
        const appConfig = target._appConfig;
        
        // 加载微应用
        this.loadApp(appConfig, target);
        
        // 停止观察
        this.observer.unobserve(target);
      }
    });
  }
  
  async loadApp(appConfig, container) {
    try {
      // 显示加载状态
      container.innerHTML = '<div class="loading">Loading...</div>';
      
      // 动态加载微应用
      const app = await import(appConfig.entry);
      
      // 挂载应用
      await app.mount({
        container,
        ...appConfig.props
      });
    } catch (error) {
      console.error('Failed to load app:', error);
      container.innerHTML = '<div class="error">Failed to load</div>';
    }
  }
}

// 使用懒加载
const lazyLoader = new LazyLoader();

// 观察容器元素
const container = document.querySelector('#lazy-app-container');
lazyLoader.observe(container, {
  entry: './micro-app.js',
  props: { theme: 'dark' }
});
```

## 7. 部署和运维

### 7.1 独立部署
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 主应用
  shell-app:
    build: ./shell-app
    ports:
      - "3000:80"
    environment:
      - REACT_APP_MICRO_APP_A_URL=http://localhost:3001
      - REACT_APP_MICRO_APP_B_URL=http://localhost:3002
  
  # 微应用 A
  micro-app-a:
    build: ./micro-app-a
    ports:
      - "3001:80"
    environment:
      - PUBLIC_PATH=/micro-app-a/
  
  # 微应用 B
  micro-app-b:
    build: ./micro-app-b
    ports:
      - "3002:80"
    environment:
      - PUBLIC_PATH=/micro-app-b/
  
  # Nginx 网关
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - shell-app
      - micro-app-a
      - micro-app-b
```

### 7.2 版本管理
```javascript
// 版本兼容性检查
class VersionManager {
  constructor() {
    this.versions = new Map();
  }
  
  registerApp(name, version, dependencies = {}) {
    this.versions.set(name, {
      version,
      dependencies,
      registeredAt: Date.now()
    });
  }
  
  checkCompatibility(appName, requiredVersion) {
    const app = this.versions.get(appName);
    if (!app) {
      throw new Error(`App ${appName} not found`);
    }
    
    return this.isVersionCompatible(app.version, requiredVersion);
  }
  
  isVersionCompatible(currentVersion, requiredVersion) {
    // 简单的语义化版本检查
    const current = this.parseVersion(currentVersion);
    const required = this.parseVersion(requiredVersion);
    
    // 主版本必须匹配
    if (current.major !== required.major) {
      return false;
    }
    
    // 次版本必须大于等于要求的版本
    if (current.minor < required.minor) {
      return false;
    }
    
    return true;
  }
  
  parseVersion(version) {
    const [major, minor, patch] = version.split('.').map(Number);
    return { major, minor, patch };
  }
}
```

### 7.3 监控和日志
```javascript
// 微前端监控
class MicroFrontendMonitor {
  constructor() {
    this.metrics = {
      loadTime: new Map(),
      errors: [],
      performance: new Map()
    };
  }
  
  // 记录应用加载时间
  recordLoadTime(appName, startTime, endTime) {
    const loadTime = endTime - startTime;
    
    if (!this.metrics.loadTime.has(appName)) {
      this.metrics.loadTime.set(appName, []);
    }
    
    this.metrics.loadTime.get(appName).push({
      loadTime,
      timestamp: Date.now()
    });
    
    // 发送到监控服务
    this.sendMetric('load_time', {
      app: appName,
      duration: loadTime,
      timestamp: Date.now()
    });
  }
  
  // 记录错误
  recordError(appName, error) {
    const errorInfo = {
      app: appName,
      message: error.message,
      stack: error.stack,
      timestamp: Date.now()
    };
    
    this.metrics.errors.push(errorInfo);
    
    // 发送错误报告
    this.sendError(errorInfo);
  }
  
  // 性能监控
  recordPerformance(appName, metrics) {
    this.metrics.performance.set(appName, {
      ...metrics,
      timestamp: Date.now()
    });
    
    this.sendMetric('performance', {
      app: appName,
      ...metrics
    });
  }
  
  sendMetric(type, data) {
    // 发送到监控服务（如 DataDog、New Relic 等）
    fetch('/api/metrics', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        type,
        data,
        timestamp: Date.now()
      })
    }).catch(console.error);
  }
  
  sendError(errorInfo) {
    // 发送到错误监控服务（如 Sentry）
    fetch('/api/errors', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(errorInfo)
    }).catch(console.error);
  }
}
```

## 8. 面试重点

### 8.1 核心概念
1. **微前端定义**：将前端应用拆分为独立的微应用
2. **实现方案**：iframe、Single-SPA、Module Federation、qiankun
3. **应用隔离**：JavaScript、CSS、DOM 隔离机制
4. **通信方式**：Props、事件总线、共享状态
5. **路由管理**：主应用和微应用的路由协调

### 8.2 技术难点
1. **样式隔离**：避免样式冲突和污染
2. **JavaScript 沙箱**：隔离全局变量和副作用
3. **性能优化**：资源预加载、缓存策略
4. **版本管理**：微应用间的依赖和兼容性
5. **调试复杂性**：跨应用的调试和错误追踪

### 8.3 适用场景
- 大型企业应用
- 多团队协作项目
- 技术栈迁移
- 遗留系统改造
- 独立部署需求

---

**学习建议**：
1. 理解微前端的设计思想和适用场景
2. 掌握主流微前端框架的使用
3. 深入了解应用隔离的实现原理
4. 实践复杂应用的拆分和集成
5. 关注性能优化和运维监控